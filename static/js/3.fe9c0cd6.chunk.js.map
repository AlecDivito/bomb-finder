{"version":3,"sources":["models/GameTypes.ts","logic/BombFinder.ts","util/InSquare.ts","logic/InputController.ts","components/Gameheader.tsx","components/Switch.tsx","components/GameFooter.tsx","components/GameBoard.tsx","pages/game.tsx","components/Button.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","logic/Animation.ts","models/GameBoardTypes.ts","util/Random.ts","logic/BombFinderPieceRenderer.ts","util/toHHMMSS.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js","models/Preferences.ts","assets/hourglass.svg","pages/page-not-found.tsx","assets/piece.svg"],"names":["InputMode","GameStatus","BombFinder","games","settings","minWidth","minHeight","Object","classCallCheck","this","pieceRenderer","grid","updateRemainingPiecesCount","remainingPieces","inputMode","TOGGLE","backgroundAnimation","height","width","offsetWidth","offsetHeight","overflowClasses","BombFinderPieceRenderer","calculatedWidth","calculateBoardSize","calculatedHeight","AnimationTimer","setMarkInput","init","markFlag","arguments","length","undefined","MARK","setTarget","setStep","play","reset","newGame","id","Error","logAndDestroy","delta","isComplete","update","gameHasStarted","totalPieces","calcDelta","time","reduce","total","cell","isVisible","visibility","isBomb","value","invisiblePieces","result","forEach","state","CellState","BOMB","Visibility","VISIBLE","board","events","includes","keys","hover","index","getIndexByPixel","pos","leftClick","INVISIBLE","totalMoves","repositionBombCell","toggleCell","setCellVisibility","rightClick","isMarkable","MARKED","markCell","_this","newIndex","bombs","area","RandInRange","getNeighbors","cellIndex","incrementCellValue","objectSpread","CLEAN","constructGrid","neighbors","visited","i","pop","isMarked","push","_this2","neighbor","_this3","pre","VISIBLY_SATISFIED","point","cellSize","gridGapSize","defaultCellSize","row","Math","floor","y","col","x","top","left","square","size","InSquare","getIndex","bombCounter","defaultCell","random","bombProximityCounter","neighborIndex","j","tempRow","tempCol","tempIndex","ctx","canvasWindow","drawBackground","drawBoard","save","gradient1","createLinearGradient","addColorStop","concat","getValue","fillStyle","fillRect","restore","totalPieceSize","startingColOffset","max","startingRowOffset","startingRow","startingCol","endingCol","min","ceil","endingRow","drawPiece","InputController","listeners","timer","touchTimer","touchThreshold","touchPoint","idCounter","mouseEvent","event","type","buttons","middleClick","pageX","pageY","stopContextMenu","preventDefault","stopPropagation","touchEvent","Date","now","targetTouches","keydownEvent","key","element","uniqueId","listeningTo","pointer","getFunctionPointer","window","addEventListener","passive","rect","getBoundingClientRect","removeEventListener","eventType","GameHeader","props","react_default","a","createElement","className","src","piece","alt","pieces","react_router_dom","to","toHHMMSS","hourglass","Switch","checked","onChange","GameFooter","isChecked","isSwitchChecked","info","src_components_Switch","flagToggle","target","GameBoard","stopUpdates","rafId","container","canvas","context2D","gameState","input","ready","gameOver","canVibrate","canTryAgain","toMainMenu","remainingAvailablePiece","changeInputMode","forceUpdate","tryAgain","_callee","newGameId","regenerator_default","wrap","_context","prev","next","sent","setState","t0","console","warn","stop","goToMainMenu","_callee2","_context2","draw","pollEvents","inputId","handleEvents","viewport","scrollLeft","scrollTop","clientWidth","clientHeight","isGameOver","flush","isGameWon","onGameFinished","navigator","vibrate","getRemainingAvailablePiece","requestAnimationFrame","getTime","prevProps","prevState","destroyGame","createGame","Games","GetById","Preferences","GetPreferences","preferences","page","document","getElementById","getContext","start","gameBoardWidth","gameBoardHeight","innerWidth","vibration","cancelAnimationFrame","react_router","route","Loading","dimensions","canvasBoardClass","gameBoardOverflowClasses","Gameheader","Button","text","onClick","components_GameFooter","isInputModeToggle","Component","Game","to404Page","toWonPage","redirecting","gameFinished","DoesGameExists","match","params","page_not_found","src_components_GameBoard","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","disabled","disabledClass","classes","_defineProperty","obj","defineProperty","enumerable","configurable","writable","d","__webpack_exports__","LoopOptions","step","loop","STOP","_home_divitoa_Program_JS_bombfinder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","playing","alternated","REPEAT","ALTERNATE","v","cv","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","pieceLength","gapSize","simpleRender","exampleCellValue","setSpinningCubes","spinningCubes","drawInvisiblePiece","drawVisibleCell","num","pow","ipcContext","impcContext","clearRect","drawImage","drawHover","getIndexByCell","overrideColor","beginPath","strokeStyle","drawRectangle","lineWidth","stroke","closePath","s","jump","rotation","drawRotatingSquare","worldX","worldY","cellLength","rotationDirection","radius","totalLength","translate","rotate","PI","moveTo","lineTo","quadraticCurveTo","alpha","cellValue","arc","innerX","innerY","gradient","createRadialGradient","fill","font","offset","ypos","xpos","textAlign","textBaseline","fillText","String","hours","minutes","seconds","timeString","_objectSpread","_defineProperty__WEBPACK_IMPORTED_MODULE_0__","source","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","Table","Field","tableName","Query","getById","cachedSettings","timestamp","assign","module","exports","p","r","react_router_dom__WEBPACK_IMPORTED_MODULE_3__","PageNotFound"],"mappings":"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","file":"static/js/3.fe9c0cd6.chunk.js","sourcesContent":["export enum InputMode {\n    TOGGLE,\n    MARK,\n}\n\nexport interface Point2d {\n    x: number;\n    y: number;\n}\n\nexport enum GameStatus {\n    GAME_PAUSED,\n    GAME_PLAY,\n}\n\nexport type GameDifficulty = \"easy\" | \"medium\" | \"hard\" | string;\n\nexport type GameProgress = \"created\" | \"inprogress\" | \"lost\" | \"won\";\n\n","import { Cell, CellState, CellValue, Visibility, isVisible, isBomb, isMarkable, isMarked, incrementCellValue } from \"../models/GameBoardTypes\";\nimport { SimpleEventState } from \"../models/EventTypes\";\nimport InSquare from \"../util/InSquare\";\nimport { Point2d, InputMode } from \"../models/GameTypes\";\nimport Games from \"../models/Games\";\nimport { IPreferences } from \"../models/Preferences\";\nimport AnimationTimer from \"./Animation\";\nimport BombFinderPieceRenderer, { CanvasWindow } from \"./BombFinderPieceRenderer\";\nimport RandInRange from \"../util/Random\";\n\nexport default class BombFinder {\n\n    // template data\n    private games: Games;\n    private settings: IPreferences;\n    private pieceRenderer: BombFinderPieceRenderer;\n\n    // game play\n    private grid: Cell[] = [];\n    private updateRemainingPiecesCount: boolean = false;\n    private remainingPieces: number = 0;\n    private inputMode: InputMode = InputMode.TOGGLE;\n\n    // animations\n    private readonly backgroundAnimation: AnimationTimer;\n\n    // canvas data\n    private readonly height: number;\n    private readonly width: number;\n    private readonly offsetWidth: number;\n    private readonly offsetHeight: number;\n    private readonly overflowClasses: string = \"\";\n\n    constructor(games: Games, settings: IPreferences, minWidth: number, minHeight: number) {\n        this.games = games;\n        this.settings = settings;\n        this.pieceRenderer = new BombFinderPieceRenderer(settings);\n\n        const calculatedWidth = this.calculateBoardSize(this.games.width);\n        const calculatedHeight = this.calculateBoardSize(this.games.height);\n\n        if (minWidth > calculatedWidth) {\n            this.width = minWidth;\n            this.offsetWidth = (this.width - calculatedWidth) / 2;;\n        } else {\n            this.overflowClasses += \" overflow-x\"; \n            this.width = calculatedWidth;\n            this.offsetWidth = 0;\n        }\n\n        if (minHeight > calculatedHeight) {\n            this.height = minHeight;\n            this.offsetHeight = (this.height - calculatedHeight) / 2;\n        } else {\n            this.overflowClasses += \" overflow-y\"; \n            this.height = calculatedHeight;\n            this.offsetHeight = 0;\n        }\n        this.backgroundAnimation = new AnimationTimer(121, 3);            \n        this.setMarkInput();\n\n        this.init();\n    }\n\n    public get isInputModeToggle() {\n        return InputMode.TOGGLE === this.inputMode;\n    }\n\n    public get gameBoardOverflowClasses() {\n        return this.overflowClasses;\n    }\n\n    public get gameBoardWidth() {\n        return this.width;\n    }\n\n    public get gameBoardHeight() {\n        return this.height;\n    }\n\n    public get gameState() {\n        return this.games.result;\n    }\n\n    public get isGameOver() {\n        return this.games.result === \"lost\" || this.games.result === \"won\";\n    }\n\n    public get isGameWon() {\n        return this.games.result === \"won\";\n    }\n\n    public get getRemainingAvailablePiece() {\n        return this.remainingPieces;\n    }\n\n    public get getTime() {\n        return Math.floor(this.games.time);\n    }\n\n    public setMarkInput(markFlag: boolean = false) {\n        this.inputMode = (markFlag) ? InputMode.MARK : InputMode.TOGGLE;\n        if (this.inputMode === InputMode.MARK) {\n            this.backgroundAnimation.setTarget(121);\n            this.backgroundAnimation.setStep(3);\n            this.backgroundAnimation.play();\n        } else if (this.inputMode === InputMode.TOGGLE) {\n            this.backgroundAnimation.setTarget(0);\n            this.backgroundAnimation.setStep(-3);\n            this.backgroundAnimation.play();\n        }\n    }\n\n    public async reset(): Promise<string> {\n        const newGame = await this.games.reset(this.games);\n        if (newGame) {\n            return newGame.id;\n        }\n        throw new Error(\"Had a problem saving old Game\");\n    }\n\n    public async logAndDestroy() {\n        return await this.games.logAndDestroy();\n    }\n\n    public update(delta: number) {\n        if (this.games.isComplete) {\n            return;\n        }\n        this.pieceRenderer.update(delta);\n        this.backgroundAnimation.update(delta);\n        if (this.games.gameHasStarted && this.remainingPieces !== this.games.totalPieces) {\n            const calcDelta = delta;\n            this.games.time += calcDelta;\n        }\n        if (this.updateRemainingPiecesCount) {\n            this.remainingPieces = this.grid.reduce((total, cell) =>\n                (isVisible(cell.visibility) && !isBomb(cell.value)) ? total - 1 : total\n            , this.games.totalPieces);\n            this.updateRemainingPiecesCount = false;\n            this.games.invisiblePieces = this.remainingPieces;\n            this.games.update();\n        }\n        if (!this.games.isComplete && (this.games.result === \"lost\" || this.remainingPieces === 0)) {\n            this.grid.forEach((cell) => {\n                if (cell.state === CellState.BOMB) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n            this.games.board = this.grid;\n            if (this.games.result === \"lost\") {\n                this.games.result = \"lost\";\n                this.games.update();\n            }\n            else if (this.remainingPieces === 0) {\n                this.games.result = \"won\";\n                this.games.update();\n            }\n            this.games.isComplete = true;\n        }\n    }\n\n    public handleEvents(events?: SimpleEventState) {\n        if (this.games.result !== \"inprogress\" && this.games.result !== \"created\") {\n            return;\n        }\n        if (!events) {\n            return;\n        }\n        if (events.events.includes(\"keydown\")) {\n            if (events.keys.includes(\"f\")) {\n                this.setMarkInput(this.inputMode === InputMode.TOGGLE);\n            }\n        }\n        if (events.events.includes(\"mousemove\")) {\n            this.grid.forEach((cell) => {\n                cell.hover = false;\n            });\n            const index = this.getIndexByPixel(events.pos);\n            if (index !== null && index < this.grid.length && this.grid[index]) {\n                this.grid[index].hover = true;\n            }\n        }\n        if (events.events.includes(\"mousedown\") || events.events.includes(\"touch\")) {\n            this.games.result = \"inprogress\";\n            const index = this.getIndexByPixel(events.pos);\n            if (index === null || index >= this.grid.length) {\n                return;\n            }\n            const cell = this.grid[index];\n            if (this.inputMode === InputMode.TOGGLE && events.leftClick && cell.visibility === Visibility.INVISIBLE) {\n                this.games.totalMoves++;\n                if (isBomb(cell.value) && this.remainingPieces === this.games.totalPieces) {\n                    // it is impossible to lose on the first move, so move the\n                    // bomb somewhere else\n                    this.repositionBombCell(index);\n                } else if (isBomb(cell.value)) {\n                    this.games.result = \"lost\";\n                }\n                if (cell.value === 0) {\n                    this.toggleCell(index);\n                }\n                this.setCellVisibility(index);\n            } else if (events.rightClick || (events.leftClick && this.inputMode === InputMode.MARK)) {\n                this.games.totalMoves++;\n                if (isMarkable(cell.visibility)) {\n                    cell.visibility = (cell.visibility === Visibility.MARKED)\n                        ? Visibility.INVISIBLE\n                        : Visibility.MARKED;\n                    this.markCell(index);\n                }\n            }\n            this.updateRemainingPiecesCount = true;\n        }\n        if (this.games.result === \"lost\") {\n            this.grid.forEach((cell) => {\n                if (isBomb(cell.value)) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n        }\n    }\n\n    /**\n     * Bomb was clicked on the first turn, therefore we need to re-position the\n     * bomb and calculate the index pieces value\n     * \n     * @param index position of cell inside grid\n     */\n    private repositionBombCell(index: number) {\n        // reposition bomb\n        // check the density of bombs on the board. if the board is too dense\n        // place the new bomb at the first non-bomb tile\n        let newIndex = 0;\n        if ((this.games.bombs / this.games.area) > 0.75) {\n            while (isBomb(this.grid[newIndex].value)) { newIndex++; }\n        } else {\n            do {\n                newIndex = RandInRange(0, this.grid.length - 1);\n            // we don't need to check if the piece is already visible because\n            // no pieces on the board are currently visible\n            } while (isBomb(this.grid[newIndex].value));\n        }\n        this.grid[newIndex] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.BOMB,\n            value: null\n        };\n        const neighbors = this.getNeighbors(index);\n        // update all the neighbors that are not bombs\n        neighbors.forEach( cellIndex => {\n            if (isBomb(this.grid[cellIndex].value)) {\n                return;\n            }\n            let value = incrementCellValue(this.grid[cellIndex].value);\n            this.grid[cellIndex] = {\n                ...this.grid[cellIndex],\n                ...{value: incrementCellValue(value)}\n            };\n        });\n        // create the new cell\n        const pieces = this.getNeighbors(index);\n        const bombs = pieces.reduce((bombs, index) =>\n            isBomb(this.grid[index].value) ? bombs + 1 : bombs\n            , 0);\n        this.grid[index] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.CLEAN,\n            value: bombs as CellValue\n        };\n    }\n\n    protected init() {\n        this.remainingPieces = this.games.invisiblePieces;\n        if (this.games.board.length === 0) {\n            this.grid = this.constructGrid();\n            this.games.board = this.grid;\n        }\n        else {\n            this.grid = this.games.board;\n        }\n    }\n\n    private toggleCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        const visited: number[] = [index];\n        while (neighbors.length > 0) {\n            const i = neighbors.pop()!;\n            if (this.grid[i].value === 0 && !isMarked(this.grid[i])) {\n                const newNeighbors = this.getNeighbors(i);\n                newNeighbors.forEach((newIndex) => {\n                    if (!neighbors.includes(newIndex) && !visited.includes(newIndex)) {\n                        neighbors.push(newIndex);\n                    }\n                });\n            }\n            this.setCellVisibility(i);\n            visited.push(i);\n        }\n    }\n\n    private markCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        neighbors.forEach((neighbor) => {\n            const cell = this.grid[neighbor];\n            if (isVisible(cell.visibility) && !isBomb(cell.value) && cell.value !== 0) {\n                this.setCellVisibility(neighbor);\n            }\n        });\n    }\n\n    private setCellVisibility(index: number) {\n        if (isMarked(this.grid[index])) {\n            return;\n        }\n        if (this.grid[index].value === null || this.grid[index].value === 0) {\n            this.grid[index].visibility = Visibility.VISIBLE;\n            return;\n        }\n        const neighbor = this.getNeighbors(index);\n        const count = neighbor.reduce((pre, index) => {\n            const cell = this.grid[index];\n            if (cell.visibility === Visibility.MARKED) {\n                return pre + 1;\n            }\n            return pre;\n        }, 0);\n        if (count >= this.grid[index].value!) {\n            this.grid[index].visibility = Visibility.VISIBLY_SATISFIED\n        } else {\n            this.grid[index].visibility = Visibility.VISIBLE;\n        }\n    }\n\n    private getIndexByPixel(point: Point2d): number | null {\n        const cellSize = this.settings.gridGapSize + this.settings.defaultCellSize;\n        const row = Math.floor((point.y - this.offsetHeight) / cellSize);\n        const col = Math.floor((point.x - this.offsetWidth) / cellSize);\n\n        // check if pointer is inside square\n        const top =  this.offsetHeight + ((row * cellSize) + this.settings.gridGapSize);\n        const left = this.offsetWidth + ((col * cellSize) + this.settings.gridGapSize);\n\n        if (row >= 0 && col >= 0 && col < this.games.width && row < this.games.height &&\n            InSquare({top, left, size: this.settings.defaultCellSize }, point)) {\n            return this.getIndex(row, col);\n        }\n        return null;\n    }\n\n    private getIndex(row: number, col: number): number {\n        return (row * this.games.width) + col;\n    }\n\n    private constructGrid(): Cell[] {\n        const grid: Array<Cell | null> = [];\n\n        // create the grid\n        for (let i = 0; i < this.games.area; i++) {\n            grid.push(null);\n        }\n\n        // place the bombs\n        let bombCounter = this.games.bombs;\n        while (bombCounter > 0) {\n            const defaultCell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.BOMB,\n            }\n            const index = Math.floor(Math.random() * this.games.area);\n\n            if (grid[index] === null) {\n                bombCounter--;\n                grid[index] = defaultCell;\n            }\n        }\n\n        // place safe spaces\n        for (let index = 0; index < grid.length; index++) {\n            if (grid[index] !== null) { // if this is a bomb\n                continue;\n            }\n\n            let bombProximityCounter = 0;\n            const neighbors = this.getNeighbors(index);\n            for (let i = 0; i < neighbors.length; i++) {\n                const neighborIndex = neighbors[i];\n                if (grid[neighborIndex] !== null && grid[neighborIndex]!.state === CellState.BOMB) {\n                    bombProximityCounter++;\n                }\n            }\n            const cell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.CLEAN,\n                value: bombProximityCounter as CellValue,\n            };\n            grid[index] = cell;\n        }\n\n        return grid as Cell[];\n    }\n\n    private getNeighbors(index: number): number[] {\n        if (index < 0 || index >= this.games.area) {\n            return [];\n        }\n        const row = Math.floor(index / this.games.width);\n        const col = index % this.games.width;\n        const neighbors = [];\n        for (let j = 0; j < 8; j++) {\n            let tempRow = row;\n            let tempCol = col;\n            switch (j) {\n                case 0:\n                    tempRow -= 1;\n                    tempCol -= 1;\n                    break;\n                case 1: tempRow -= 1; break;\n                case 2:\n                    tempRow -= 1;\n                    tempCol += 1;\n                    break;\n                case 3: tempCol -= 1; break;\n                case 4: tempCol += 1; break;\n                case 5:\n                    tempRow += 1;\n                    tempCol -= 1;\n                    break;\n                case 6: tempRow += 1; break;\n                case 7:\n                    tempRow += 1;\n                    tempCol += 1;\n                    break;\n            }\n            const tempIndex = this.getIndex(tempRow, tempCol);\n            if (tempRow >= 0 && tempRow < this.games.height && // check if the index is in the gird\n                tempCol >= 0 && tempCol < this.games.width) {\n                neighbors.push(tempIndex);\n            }\n        }\n        \n        return neighbors;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        // TODO: futher optimizations \n        // TODO: Render screen differences only, not the whole new state.\n        this.drawBackground(ctx);\n        this.drawBoard(ctx, canvasWindow);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        const gradient1 = ctx.createLinearGradient(this.width / 2,\n            this.height, this.width / 2, 0);\n        gradient1.addColorStop(0.05, '#333');\n        gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 50%, 1)`);\n        ctx.fillStyle = gradient1;\n        ctx.fillRect(0, 0, this.width, this.height);\n        ctx.restore();\n    }\n\n    private drawBoard(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        const totalPieceSize = this.settings.defaultCellSize + this.settings.gridGapSize;\n        const startingColOffset = Math.max(this.width, canvasWindow.width) - canvasWindow.width;\n        const startingRowOffset = Math.max(this.height, canvasWindow.height) - canvasWindow.height;\n\n        const startingRow = Math.floor(canvasWindow.x / (totalPieceSize + startingColOffset + 1));\n        const startingCol = Math.floor(canvasWindow.y / (totalPieceSize + startingRowOffset + 1));\n\n        const endingCol = Math.min(Math.ceil(\n            (canvasWindow.x + canvasWindow.width - this.offsetWidth) / totalPieceSize) + 1,\n            this.games.width);\n        const endingRow = Math.min(Math.ceil(\n            (canvasWindow.y + canvasWindow.height - this.offsetHeight) / totalPieceSize) + 1,\n            this.games.height);\n\n        for (let row = startingRow; row < endingRow; row++) {\n            for (let col = startingCol; col < endingCol; col++) {\n                // position\n                const x = this.offsetWidth + this.calculateBoardSize(col);\n                const y = this.offsetHeight + this.calculateBoardSize(row);\n                const index = this.getIndex(row, col);\n                const cell = this.grid[index];\n\n                /**\n                 * This is what I want to be able to call\n                 */\n                if (cell) {\n                    this.pieceRenderer.drawPiece(ctx, cell, x, y);\n                }\n            }    \n        }\n    }\n\n    private calculateBoardSize(size: number) {\n        return (size * this.settings.defaultCellSize) + ((size + 1) * this.settings.gridGapSize)\n    }\n}\n","import { Point2d } from \"../models/GameTypes\";\n\nexport default function InSquare(square: {\n    top: number,\n    left: number,\n    size: number,\n}, point: Point2d): boolean {\n    return point.y >= square.top && point.y <= square.top + square.size &&\n        point.x >= square.left && point.x <= square.left + square.size\n}","import { SimpleEventState } from \"../models/EventTypes\";\nimport { Point2d } from \"../models/GameTypes\";\n\ninterface Listener {\n    element: HTMLElement;\n    listeningTo: Array<keyof HTMLElementEventMap>;\n}\n\n// why not use\n// https://reactjs.org/docs/events.html#pointer-events\nexport default class InputController {\n\n    private listeners: { [key: number]: Listener } = {};\n    private timer: number = 0;\n    private touchTimer: number = 0;\n    private touchThreshold: number = 300;\n    private touchPoint?: Point2d;\n    private idCounter: number = 0;\n\n    private state?: SimpleEventState;\n\n    /**\n     * Place event listeners on a html element\n     * \n     * @param {HTMLElement} element element events to be placed on\n     * @param {String[]} events events to subscribe to\n     * @returns {number} id that tracks your current input session\n     */\n    public start(element: HTMLElement, events: Array<keyof HTMLElementEventMap>): number {\n        // add to listeners\n        const id = this.uniqueId();\n        this.listeners[id] = {\n            element,\n            listeningTo: []\n        };\n\n        events.forEach((event) => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.addEventListener(event, pointer as any);\n            }\n            else {\n                this.listeners[id].element.addEventListener(event, pointer as any, {\n                    passive: event !== \"contextmenu\",\n                });\n            }\n            this.listeners[id].listeningTo.push(event);\n        });\n\n        return id;\n    }\n\n    /**\n     * Get all event that happened\n     * \n     * Remember to call flush() or else you will get old events that persisted\n     * between frames\n     * \n     * @param {number} id - The events binded to the element you want\n     * @returns {Point2d | null} returns mouses new position or null if the \n     *      mouse hasn't moved since last checked\n     */\n    public pollEvents(id: number): SimpleEventState | undefined {\n        if (this.state) {\n            const rect = this.listeners[id].element.getBoundingClientRect();\n            this.state.pos.x -= rect.left;\n            this.state.pos.y -= rect.top;\n        }\n        return this.state;\n    }\n\n    /**\n     * Remove all of the input state from the controller\n     * @returns {void} \n     */\n    public flush() {\n        this.state = undefined;\n    }\n\n    public stop(id: number): boolean {\n        if (this.listeners[id] === undefined) {\n            return false;\n        }\n\n        this.listeners[id].listeningTo.forEach(event => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.removeEventListener(event, pointer as any);\n            } else {\n                this.listeners[id].element.removeEventListener(event, pointer as any);\n            }\n        });\n\n        return true;\n    }\n\n    private getFunctionPointer(eventType: keyof HTMLElementEventMap) {\n        switch (eventType) {\n            case \"mousemove\": return this.mouseEvent;\n            case \"mousedown\": return this.mouseEvent;\n            case \"mouseup\": return this.mouseEvent;\n            case \"contextmenu\": return this.stopContextMenu;\n            case \"touchstart\": return this.touchEvent;\n            case \"touchmove\": return this.touchEvent;\n            case \"touchend\": return this.touchEvent;\n            case \"keydown\": return this.keydownEvent;\n        }\n    }\n\n    private mouseEvent = (event: MouseEvent) => {\n        if (this.touchPoint) { // this means touch is active\n            return;\n        }\n        if (this.state && this.state.events.includes(\"touch\")) {\n            return;\n        }\n\n        // because state already exists, we need to add new data types\n        // this is because if a mousemove happens first then a mousedown event\n        // happens, the left, middle, and right click events won't update\n        if (this.state) {\n            this.state.events.push(event.type as any);\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousemove\") {\n            this.state.pos = {\n                x: event.pageX,\n                y: event.pageY,\n            };\n            return;\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousedown\") {\n            this.state.leftClick = [1, 3, 5, 7].includes(event.buttons);\n            this.state.middleClick = [4, 5, 6, 7].includes(event.buttons);\n            this.state.rightClick = [2, 3, 6, 7].includes(event.buttons);\n            return;\n        }\n        // state has not been initialized so create it.\n        this.state = {\n            leftClick: [1, 3, 5, 7].includes(event.buttons),\n            middleClick: [4, 5, 6, 7].includes(event.buttons),\n            rightClick: [2, 3, 6, 7].includes(event.buttons),\n            pos: {\n                x: event.pageX,\n                y: event.pageY,\n            },\n            keys: [],\n            events: [event.type as any]\n        };\n    }\n\n    private stopContextMenu = (event: any) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    }\n\n    private touchEvent = (event: TouchEvent) => {\n        if (event.type === \"touchstart\") {\n            if (this.touchTimer === 0) {\n                this.timer = Date.now();\n            }\n            this.touchPoint = {\n                x: event.targetTouches[0].pageX,\n                y: event.targetTouches[0].pageY,\n            };\n            return;\n        }\n\n        if (event.type === \"touchmove\") {\n            this.touchPoint = undefined;\n            return;\n        }\n\n        if (event.type === \"touchend\" && this.touchPoint) {\n            const delta = Date.now() - this.timer;\n            this.timer = Date.now();\n            this.touchTimer += delta;\n            this.state = {\n                leftClick: this.touchTimer < this.touchThreshold,\n                middleClick: false,\n                rightClick: this.touchTimer > this.touchThreshold,\n                pos: this.touchPoint!,\n                keys: (this.state) ? this.state!.keys : [],\n                events: [\"touch\"]\n            }\n            this.touchPoint = undefined;\n            this.touchTimer = 0;\n        }\n    }\n\n    private keydownEvent = (event: KeyboardEvent) => {\n        if(this.state) {\n            this.state.events.push(event.type as any);\n        }\n        if (this.state) {\n            this.state.keys.push(event.key);\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1 },\n                keys: [event.key],\n                events: [event.type as any]\n            };\n        }\n    }\n\n    private uniqueId() {\n        return this.idCounter++;\n    }\n}\n","import React from 'react';\nimport toHHMMSS from '../util/toHHMMSS';\nimport piece from \"../assets/piece.svg\";\nimport hourglass from \"../assets/hourglass.svg\";\nimport \"./Header.css\"\nimport { Link } from 'react-router-dom';\n\ninterface Props {\n    time: number;\n    left: number;\n    pieces: number;\n}\n\nconst GameHeader: React.FC<Props> = (props: Props) => {\n    return <header className=\"header  header--game\">\n        <div className=\"header__detail\" >\n            <img src={piece} alt=\"Home\" />\n            <span>{props.left}/{props.pieces}</span>\n        </div>\n        <h3>\n            <Link to=\"/\">BombFinder</Link>\n        </h3>\n        <div className=\"header__detail\">\n            <span>{toHHMMSS(props.time)}</span>\n            <img src={hourglass} alt=\"Home\" />\n        </div>\n    </header>\n}\n\nexport default GameHeader;","import React from 'react';\nimport \"./Switch.css\";\n\ninterface Props {\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Switch: React.FC<Props> = (props: Props) => {\n    return <label className=\"switch\">\n        <input\n            checked={props.checked}\n            onChange={props.onChange}\n            className=\"switch__input\"\n            type=\"checkbox\" />\n        <span className=\"switch__box\">\n            <span className=\"switch__marker\" />\n        </span>\n    </label>\n}\n\nexport default Switch;","import React from 'react';\nimport info from \"../assets/info.svg\";\nimport settings from \"../assets/cog-f.svg\";\nimport { Link } from 'react-router-dom';\nimport \"./Footer.css\"\nimport Switch from './Switch';\n\ninterface Props {\n    isSwitchChecked?: boolean;\n    flagToggle: (value: boolean) => void;\n}\n\nconst GameFooter: React.FC<Props> = (props: Props) => {\n    const isChecked = (props.isSwitchChecked) ? true : false;\n    return (\n        <footer className=\"footer footer--game\">\n            <Link to=\"/how-to-play\">\n                <img src={info} alt=\"Info\" />\n            </Link>\n            <div className=\"footer__text\">\n                <span>Clear</span>\n                <Switch\n                    checked={isChecked}\n                    onChange={(event: any) => props.flagToggle(event.target.checked) }/>\n                <span>Flag</span>\n            </div>\n            <Link to=\"/settings\">\n                <img src={settings} alt=\"Settings\" />\n            </Link>\n        </footer>\n    );\n}\n\nexport default GameFooter;","import React, { Component } from 'react';\nimport BombFinder from \"../logic/BombFinder\";\nimport InputController from \"../logic/InputController\";\nimport { Redirect } from 'react-router-dom';\nimport { GameProgress } from '../models/GameTypes';\nimport { CanvasWindow } from '../logic/BombFinderPieceRenderer';\nimport Games from '../models/Games';\nimport Loading from './Loading';\nimport Preferences from '../models/Preferences';\nimport Button from './Button';\nimport GameHeader from './Gameheader';\nimport GameFooter from './GameFooter';\nimport './GameBoard.css';\n\ninterface Props {\n    id: string;\n    onGameFinished: (result: GameProgress) => void\n}\n\ninterface State {\n    ready: boolean;\n    gameOver: boolean;\n    canVibrate: boolean;\n    canTryAgain: boolean;\n    toMainMenu: boolean;\n    totalPieces: number;\n    remainingAvailablePiece: number;\n    newGameId?: string;\n    inputId?: number;\n    time: number;\n}\n\nclass GameBoard extends Component<Props, State> {\n\n    private stopUpdates: boolean = false;\n    private rafId?: number;\n\n    private container?: HTMLDivElement;\n    private canvas?: HTMLCanvasElement;\n    // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#Turn_off_transparency\n    private context2D?: CanvasRenderingContext2D;\n    private gameState?: BombFinder;\n    private input?: InputController;\n\n    state: Readonly<State> = {\n        ready: false,\n        gameOver: false,\n        canVibrate: false,\n        canTryAgain: false,\n        toMainMenu: false,\n        totalPieces: 0,\n        remainingAvailablePiece: 0,\n        time: 0,\n    }\n\n    public componentDidUpdate(prevProps: Props, prevState: State) {\n        if (prevState.newGameId && prevProps.id !== prevState.newGameId) {\n            // new game has started without unmounting the component\n            this.setState({\n                ready: false,\n                gameOver: false,\n                canTryAgain: false,\n                time: 0,\n                newGameId: undefined,\n                inputId: undefined,\n            });\n            this.destroyGame();\n            this.createGame();\n        }\n    }\n\n    public async componentDidMount() {\n        this.createGame();\n    }\n\n    public componentWillUnmount() {\n        this.stopUpdates = true;\n        this.destroyGame();\n    }\n\n    public async createGame() {\n        // TODO: GetById error handling\n        const games = await Games.GetById(this.props.id)!;\n        const preferences = await Preferences.GetPreferences();\n        const page = document.getElementById(\"page\") as HTMLDivElement;\n        if (games.result === \"won\") {\n            this.props.onGameFinished(games.result);\n            return;\n        }\n        // TODO: Remove magic number\n        this.gameState = new BombFinder(games, preferences, page.clientWidth, page.clientHeight - 120);\n        this.input = new InputController();\n        this.setState({\n            ready: true,\n            totalPieces: games.totalPieces,\n            remainingAvailablePiece: this.gameState.getRemainingAvailablePiece\n        });\n        this.canvas = document.getElementById(\"board\") as HTMLCanvasElement;\n        this.container = document.getElementById(\"board-container\") as HTMLDivElement;\n        this.context2D = this.canvas.getContext(\"2d\")!;\n\n        const inputId = this.input.start(this.canvas!, [\"mousemove\", \"mousedown\",\n            \"contextmenu\", \"touchstart\", \"touchmove\", \"touchend\", \"keydown\"]);\n\n        // TODO: Add error handling\n        this.canvas!.width = this.gameState!.gameBoardWidth;\n        this.canvas!.height = this.gameState!.gameBoardHeight;\n        this.container.scrollLeft = (this.gameState!.gameBoardWidth - window.innerWidth) / 2;\n        this.setState({ ready: true, inputId: inputId, canVibrate: preferences.vibration });\n        requestAnimationFrame(this.draw);\n    }\n\n    public destroyGame() {\n        if (this.state.ready && this.state.inputId) {\n            this.input!.stop(this.state.inputId!);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId!);\n        }\n    }\n\n    public changeInputMode = (markFlag: boolean) => {\n        this.gameState!.setMarkInput(markFlag);\n        this.forceUpdate();\n    }\n\n    public tryAgain = async () => {\n        if (this.state.ready && !this.state.newGameId && this.state.canTryAgain) {\n            try {\n                const newGameId = await this.gameState!.reset();\n                this.setState({ ready: false, newGameId });\n            } catch (e) {\n                console.warn(\"error \" + e);\n                // TODO: implement Error handling\n            }\n        }\n    }\n\n    public goToMainMenu = async () => {\n        if (this.state.ready) {\n            const logged = await this.gameState!.logAndDestroy();\n            if (logged) {\n                this.setState({toMainMenu: true});\n            }\n        }\n    }\n\n    public render() {\n        if (this.state.toMainMenu) {\n            return <Redirect to=\"/\" />;\n        }\n        if (this.state.newGameId) {\n            const route = `/game/${this.state.newGameId}`;\n            return <Redirect to={route} />;\n        }\n        if (!this.state.ready) {\n            return <Loading />\n        }\n        const dimensions = {\n            height: this.gameState!.gameBoardHeight,\n            width: this.gameState!.gameBoardWidth,\n        };\n        let canvasBoardClass = \"board__canvas \" + this.gameState!.gameBoardOverflowClasses;\n        return (\n            <div className=\"board\">\n                <GameHeader time={this.gameState!.getTime}\n                    left={this.state.remainingAvailablePiece}\n                    pieces={this.state.totalPieces}/>\n                <div className={canvasBoardClass} id=\"board-container\">\n                    <canvas id=\"board\"\n                        className={this.gameState!.gameState}\n                        width={dimensions.width}\n                        height={dimensions.height} />\n                    {(this.state.gameOver)\n                        ? <div className=\"board__popup\">\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Try Again\"\n                                onClick={this.tryAgain} />\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Main Menu\"\n                                onClick={this.goToMainMenu} />\n                        </div>\n                        : null\n                    }\n                </div>\n                <GameFooter\n                    isSwitchChecked={!this.gameState!.isInputModeToggle}\n                    flagToggle={this.changeInputMode} />\n            </div>\n        );\n    }\n\n    private draw = () => {\n        if (!this.state.ready) {\n            // TODO: do we need this ready check for the game?????\n            return;\n        }\n        const elapsedTime = 0.0167;\n        const events = this.input!.pollEvents(this.state.inputId!);\n        \n        if (events) {\n            this.gameState!.handleEvents(events);\n            if (events.keys.length > 0) {\n                this.forceUpdate();\n            }\n        }\n        this.gameState!.update(elapsedTime);\n        // TODO: calculate playing area and send it to draw\n        const viewport: CanvasWindow = {\n            x: this.container!.scrollLeft, y: this.container!.scrollTop,\n            width: this.container!.clientWidth, height: this.container!.clientHeight\n        };\n        this.gameState!.draw(this.context2D!, viewport);\n        \n        // Initial draw call before any events\n        if (this.rafId === undefined || this.gameState!.isGameOver) {\n            this.gameState!.draw(this.context2D!, viewport);\n        }\n        \n        this.input!.flush();\n        \n        \n        if (this.gameState!.isGameOver) {\n            if (this.gameState!.isGameWon) {\n                this.props.onGameFinished(\"won\");\n            } else {\n                if (this.state.canVibrate && navigator.vibrate) {\n                    navigator.vibrate(200);\n                }\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    gameOver: true,\n                    canVibrate: false,\n                    canTryAgain: true,\n                });\n            }\n        }\n\n        if (!this.stopUpdates) {\n            this.rafId = requestAnimationFrame(this.draw);\n            if (this.state.time !== this.gameState!.getTime) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    time: this.gameState!.getTime\n                });\n            } else if (this.state.remainingAvailablePiece !== this.gameState!.getRemainingAvailablePiece) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece\n                });\n            }\n        }\n    }\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport { GameProgress } from '../models/GameTypes';\nimport GameBoard from '../components/GameBoard';\nimport { RouteComponentProps, Redirect } from 'react-router';\nimport Games from '../models/Games';\nimport PageNotFound from './page-not-found';\n\ninterface ParamProps {\n    id: string;\n}\n\ntype Props = RouteComponentProps<ParamProps>;\n\ninterface State {\n    // for when the game is done\n    to404Page: boolean;\n    toWonPage: boolean;\n    redirecting: boolean;\n    ready: boolean;\n}\n\nexport default class Game extends Component<Props, State> {\n\n    state: Readonly<State> = {\n        to404Page: false,\n        toWonPage: false,\n        redirecting: false,\n        ready: false,\n    }\n\n    async componentDidMount() {\n        const exists = await Games.DoesGameExists(this.props.match.params.id);\n        if (exists) {\n            this.setState({ to404Page: false, ready: true });\n        }\n        else {\n            this.setState({ to404Page: true, ready: true });\n        }\n    }\n\n    gameFinished = (result: GameProgress) => {\n        this.setState({ toWonPage: result === \"won\" });\n    }\n\n    public render() {\n        if (this.state.toWonPage) {\n            return <Redirect to={`/game/${this.props.match.params.id}/game-won`} />\n        }\n        else if (this.state.to404Page) {\n            return <PageNotFound />;\n        }\n        else if (this.state.ready) {\n            return <GameBoard\n                id={this.props.match.params.id}\n                onGameFinished={this.gameFinished} />\n        } else {\n            return null;\n        }\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","\nexport enum LoopOptions {\n    REPEAT,\n    ALTERNATE,\n    STOP\n}\n\nexport default class AnimationTimer {\n\n    private playing: boolean;\n    private timer = 0;\n    private target: number;\n    private step: number;\n    private loop: LoopOptions;\n    private alternated: boolean;\n\n    constructor(target: number, step: number, loop: LoopOptions = LoopOptions.STOP) {\n        this.timer = 0;\n        this.target = target;\n        this.step = step;\n        this.loop = loop;\n        this.alternated = false;\n        this.playing = true;\n    }\n\n    update(delta: number) {\n        if (!this.isComplete() && this.playing) {\n            this.timer += this.step;\n        } else {\n            if (this.loop === LoopOptions.REPEAT) {\n                this.timer = this.timer % this.target;\n            } else if (this.loop === LoopOptions.ALTERNATE) {\n                this.setStep(this.step * -1);\n                if (!this.alternated) {\n                    this.timer = 0;\n                } else {\n                    this.timer = this.target;\n                }\n            } else if (this.loop === LoopOptions.STOP) {\n                this.timer = this.target;\n                this.stop();\n            }\n        }\n    }\n\n    public stop() {\n        this.playing = false;\n    }\n\n    public play() {\n        this.playing = true;\n    }\n\n    public getValue() {\n        return this.timer;\n    }\n\n    public setTarget(target: number) {\n        this.target = target;\n    }\n\n    public setStep(step: number) {\n        if (step < 0) {\n            this.alternated = true;\n        } else {\n            this.alternated = false;\n        }\n        this.step = step;\n    }\n\n    public isComplete() {\n        return (this.alternated)\n            ? this.timer <= 0\n            : this.timer >= this.target;\n    }\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const incrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        case 3: return 4;\n        case 4: return 5;\n        case 5: return 6;\n        case 6: return 7;\n        case 7: return 8;\n        // these last 2 cases should rarely be called\n        case 8: return 8;\n        default: return null\n    }\n}\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import AnimationTimer, { LoopOptions } from \"./Animation\";\nimport { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    private pieceAnimations: AnimationTimer[] = [];\n\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.pieceLength = settings.defaultCellSize;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = this.pieceLength + 2;\n        this.invisiblePieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, 1, 1);\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = this.pieceLength + 2;\n        this.invisibleMarkedPieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, 1, 1, \"#3396ff\");\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = this.pieceLength + 2;\n            this.staticPieceCanvas[i].height = this.pieceLength + 2;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 1, 1.5, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 1, 1.5, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 1, 1.5, 0);\n            } else {\n                this.drawVisibleCell(ctx, 1, 1.5, undefined);\n            }\n        }\n    }\n\n    setCellSize(value: number) {\n        this.pieceLength = value;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(\n                new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    update(delta: number) {\n        if (this.simpleRender) {\n            return;\n        }\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            this.pieceAnimations[i].update(delta);\n        }\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        ipcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        impcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, 1, 1);\n        this.drawInvisiblePiece(impcContext, 1, 1, \"#3396ff\");\n    }\n\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, \"#3396ff\"); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, \"#3396ff\"); break;\n        }\n        ctx.restore();\n    }\n\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                this.drawHover(ctx, x + 1, y + 1);\n                // add this as a debug feature cause its actually cool\n                // const index = this.getIndexByCell(cell);\n                // ctx.drawImage(this.staticPieceCanvas[index], x, y);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n\n        if (this.simpleRender) {\n            return;\n        }\n\n        ctx.save();\n        let s = this.pieceLength;\n        let jump = 0;\n        for (let i = 1; i < this.pieceAnimations.length; i++) {\n            const rotation = (i % 2 === 0) ? 1 : -1;\n            this.drawRotatingSquare(ctx, jump + x, jump + y, s, i, rotation, overrideColor);\n            jump += (s / 4) / 2;\n            s = (s / 4) * 3;\n        }\n        ctx.restore();\n    }\n\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotationDirection: 1 | -1, overrideColor?: string) {\n        const radius = cellLength / 8;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - (radius);\n        let y = worldY + cellLength / 4 - (radius);\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + totalLength / 2, y + totalLength / 2);\n        ctx.rotate(this.pieceAnimations[i].getValue() *  Math.PI / 180);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawRectangle(ctx, x, y, radius, totalLength);\n        ctx.lineWidth = 2;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"gray\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    private drawRectangle(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        let alpha = 1.0;\n        for (let i = 1; i <= (this.gapSize / 2); i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawRectangle(ctx, x - i, y - i, (this.pieceLength) / 8,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= 0.1;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + 2;\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = 2;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","export default function toHHMMSS(time: number) {\n    time = Math.floor(time);\n    const hours = Math.floor(time / 3600);\n    const minutes = Math.floor((time - (hours * 3600)) / 60);\n    const seconds = time - (hours * 3600) - (minutes * 60);\n    let timeString = \"\";\n\n    if (hours > 0) {\n        timeString += (hours < 10) ? `0${hours}:` : `${hours}:`;\n    }\n    timeString += (minutes < 10) ? `0${minutes}:` : `${minutes}:`;\n    timeString += (seconds < 10) ? `0${seconds}` : `${seconds}`;\n\n    return timeString;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}","module.exports = __webpack_public_path__ + \"static/media/hourglass.63a5448b.svg\";","import React from 'react';\nimport \"../components/Button.css\"\nimport \"./page-not-found.css\"\nimport { Link } from 'react-router-dom';\n\nconst PageNotFound: React.FC = () => {\n    return <div className=\"page-not-found\">\n        <h1>404</h1>\n        <div className=\"page-not-found__message\">\n            Looks like you've lost your way\n        </div>\n        <Link to=\"/\" className=\"link-button page-not-found__btn\">\n            Go Home\n        </Link>\n    </div>\n}\n\nexport default PageNotFound;","module.exports = __webpack_public_path__ + \"static/media/piece.e03fada0.svg\";"],"sourceRoot":""}