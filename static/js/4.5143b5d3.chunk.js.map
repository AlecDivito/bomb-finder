{"version":3,"sources":["components/Slider.tsx","pages/settings.tsx","components/Button.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","models/GameBoardTypes.ts","util/Random.ts","logic/BombFinderPieceRenderer.ts","components/CheckBox.tsx","models/Preferences.ts"],"names":["Slider","_ref","text","name","value","max","min","onChange","maximum","minimum","react_default","a","createElement","className","htmlFor","type","id","Settings","keepUpdating","rafId","canvas","ctx","pieceRenderer","handleChange","event","target","checked","parseInt","isNaN","_this","setCellSize","setGapSize","setSpinningCubes","setSimpleRender","setState","Object","defineProperty","handleSubmit","preventDefault","timestamp","Date","Preferences","Save","state","draw","delta","size","defaultCellSize","gridGapSize","fillStyle","fillRect","update","forEach","c","i","index","x","y","drawPlaceHolder","requestAnimationFrame","GetPreferences","preferences","this","document","getElementById","getContext","BombFinderPieceRenderer","cancelAnimationFrame","Loading","dimensions","onSubmit","src_components_Slider","spinningCubes","CheckBox","simpleRender","width","height","firstMoveHandicap","vibrantColors","vibration","Button","toLocaleString","Component","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","disabled","onClick","disabledClass","classes","concat","_defineProperty","obj","key","enumerable","configurable","writable","d","__webpack_exports__","Visibility","isVisible","isMarkable","isMarked","CellState","incrementCellValue","decrementCellValue","isBomb","v","VISIBLE","VISIBLY_SATISFIED","MARKED","INVISIBLE","cell","visibility","cv","undefined","RandInRange","Math","floor","random","settings","_home_divitoa_Program_JS_bombfinder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","RECTANGLE_REDIS_DEGREE","LINE_WIDTH_DEGREE","ROTATING_LINE_WIDTH_DEGREE","PIECE_MARKED_COLOR","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","lineWidth","pieceLength","gapSize","exampleCellValue","reverseTiming","drawInvisiblePiece","drawVisibleCell","num","push","length","reverse","oldTime","newTime","sin","every","b","ipcContext","impcContext","clearRect","arguments","save","restore","drawImage","hover","offset","drawHover","getIndexByCell","overrideColor","s","rotation","pow","drawRotatingSquare","beginPath","strokeStyle","drawSquare","stroke","closePath","worldX","worldY","cellLength","radius","totalLength","translate","rotate","moveTo","lineTo","quadraticCurveTo","alpha","step","cellValue","arc","PI","innerX","innerY","gradient","createRadialGradient","addColorStop","fill","font","ypos","xpos","textAlign","textBaseline","fillText","String","Table","Field","tableName","Query","getById","cachedSettings","assign"],"mappings":"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","file":"static/js/4.5143b5d3.chunk.js","sourcesContent":["import React from 'react';\nimport \"./Slider.css\"\nimport \"./Input.css\"\n\ninterface Props {\n    text: string;\n    name: string;\n    value: number;\n    max?: number;\n    min?: number;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Slider: React.FC<Props> = ({text, name, value, max, min, onChange}) => {\n    let maximum = (max) ? max : 100;\n    let minimum = (min) ? min : 0;\n    return <div className=\"form-input slider\">\n        <label htmlFor={name}>{text} ({value})</label>\n        <input type=\"range\"\n            id={name}\n            name={name}\n            value={value}\n            max={maximum}\n            min={minimum}\n            onChange={onChange} />\n    </div>\n}\n\nexport default Slider;","import React, { Component } from \"react\";\nimport Preferences, { IPreferences } from \"../models/Preferences\";\nimport CheckBox from \"../components/CheckBox\";\nimport Slider from \"../components/Slider\";\nimport Loading from \"../components/Loading\";\nimport Button from \"../components/Button\";\nimport BombFinderPieceRenderer from \"../logic/BombFinderPieceRenderer\";\nimport \"./settings.css\";\n\nexport default class Settings extends Component<{}, IPreferences> {\n\n    private keepUpdating: boolean = true;\n    private rafId: number = 0;\n    private canvas?: HTMLCanvasElement;\n    private ctx?: CanvasRenderingContext2D;\n    private pieceRenderer?: BombFinderPieceRenderer;\n\n    async componentDidMount() {\n        const preferences = await Preferences.GetPreferences();\n        this.setState(preferences);\n        this.canvas = document.getElementById('preview') as HTMLCanvasElement;\n        this.ctx = this.canvas.getContext('2d')!;\n        this.pieceRenderer = new BombFinderPieceRenderer(preferences);\n        requestAnimationFrame(this.draw);\n    }\n\n    componentWillUnmount() {\n        this.keepUpdating = false;\n        cancelAnimationFrame(this.rafId);\n    }\n\n    handleChange = (event: any) => {\n        const target = event.target;\n        let value;\n        if (target.type === \"checkbox\") {\n            value = target.checked;\n        }\n        else {\n            value = parseInt(target.value, 10);\n            if (isNaN(value)) {\n                value = 0;\n            }\n        }\n        const name = target.name;\n\n        switch(name) {\n            case \"defaultCellSize\": this.pieceRenderer!.setCellSize(value); break;\n            case \"gridGapSize\":     this.pieceRenderer!.setGapSize(value); break;\n            case \"spinningCubes\":   this.pieceRenderer!.setSpinningCubes(value); break;\n            case \"simpleRender\":    this.pieceRenderer!.setSimpleRender(value); break;\n        }\n\n        this.setState({\n            [name]: value\n        } as Pick<Preferences, keyof Preferences>);\n    }\n\n    handleSubmit = (event: any) => {\n        event.preventDefault();\n        this.setState({\n            timestamp: new Date()\n        });\n        Preferences.Save(this.state);\n    }\n\n    draw = (delta: number) => {\n        const elapsedTime = 0.0167;\n        // clear board\n        const size = (this.state.defaultCellSize * 2) + this.state.gridGapSize;\n        this.ctx!.fillStyle = \"#333\";\n        this.ctx!.fillRect(0, 0, size, size);\n        // update and draw place holders\n        this.pieceRenderer!.update(elapsedTime);\n        [0, 0, 1, 1].forEach((c, i) => {\n            const index = (i % 2);\n            const x = 3 + (index * this.state.defaultCellSize) + (this.state.gridGapSize * index);\n            const y = 3 + (c * this.state.defaultCellSize) + (this.state.gridGapSize * c);\n            this.pieceRenderer!.drawPlaceHolder(this.ctx!, x, y, i);\n        });\n        if (this.keepUpdating) {\n            this.rafId = requestAnimationFrame(this.draw);\n        }\n    }\n\n    public render() {\n        if (!this.state) {\n            return <Loading />;\n        }\n        const dimensions = (this.state.defaultCellSize * 2) + this.state.gridGapSize * 2;\n        return (\n            <div className=\"settings\">\n                <h1>Settings</h1>\n                <form onSubmit={this.handleSubmit}>\n                    {/* <h3>User preferences</h3> */}\n\n                    <Slider text=\"Piece Length\"\n                        name=\"defaultCellSize\"\n                        max={125}\n                        min={25}\n                        value={this.state.defaultCellSize}\n                        onChange={this.handleChange} />\n\n                    <Slider text=\"Piece Gap\"\n                        name=\"gridGapSize\"\n                        max={50}\n                        min={0}\n                        value={this.state.gridGapSize}\n                        onChange={this.handleChange} />\n\n                    <Slider text=\"Spinning Cubes\"\n                        name=\"spinningCubes\"\n                        max={8}\n                        min={1}\n                        value={this.state.spinningCubes}\n                        onChange={this.handleChange} />\n\n                    <CheckBox text=\"Simple Render\"\n                        name=\"simpleRender\"\n                        checked={this.state.simpleRender}\n                        onChange={this.handleChange} />\n\n                    <h3>Grid Preview</h3>\n                    <div className=\"form-input center\">\n                        <canvas id=\"preview\" width={dimensions} height={dimensions}/>\n                    </div>\n\n                    <CheckBox text=\"Can't lose on first move\"\n                        name=\"firstMoveHandicap\"\n                        checked={this.state.firstMoveHandicap}\n                        onChange={this.handleChange} />\n\n                    <CheckBox text=\"Vibrant Colors\"\n                        name=\"vibrantColors\"\n                        checked={this.state.vibrantColors}\n                        onChange={this.handleChange} />\n\n                    <CheckBox text=\"Vibrations\"\n                        name=\"vibration\"\n                        checked={this.state.vibration}\n                        onChange={this.handleChange} />\n                    \n                    <Button type=\"submit\" text=\"Save Changes\"/>\n                </form>\n                <p>\n                    <small>\n                        <strong>Last saved: </strong>\n                        <time>{this.state.timestamp.toLocaleString()}</time>\n                    </small>\n                </p>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const incrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        case 3: return 4;\n        case 4: return 5;\n        case 5: return 6;\n        case 6: return 7;\n        case 7: return 8;\n        // these last 2 cases should rarely be called\n        case 8: return 8;\n        default: return null\n    }\n}\n\nexport const decrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 1: return 0;\n        case 2: return 1;\n        case 3: return 2;\n        case 4: return 3;\n        case 5: return 4;\n        case 6: return 5;\n        case 7: return 6;\n        case 8: return 7;\n        // these last 2 cases should rarely be called\n        case 0: return 0;\n        default: return null\n    }\n}\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n    /**\n     * Constants\n     */\n    private readonly RECTANGLE_REDIS_DEGREE = 6;\n    private readonly LINE_WIDTH_DEGREE = 20;\n    private readonly ROTATING_LINE_WIDTH_DEGREE = 60;\n    private readonly PIECE_MARKED_COLOR = \"#3396ff\";\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    // private pieceAnimations: AnimationTimer[] = [];\n    private pieceAnimations: number[] = [];\n\n    private lineWidth: number;\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.lineWidth = settings.defaultCellSize / this.LINE_WIDTH_DEGREE;\n        this.pieceLength = settings.defaultCellSize - this.lineWidth * 2;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = settings.defaultCellSize;\n        this.invisiblePieceCanvas.width =  settings.defaultCellSize;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, this.lineWidth, this.lineWidth);\n\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = settings.defaultCellSize;\n        this.invisibleMarkedPieceCanvas.width = settings.defaultCellSize;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, this.lineWidth, this.lineWidth, this.PIECE_MARKED_COLOR);\n\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = settings.defaultCellSize;\n            this.staticPieceCanvas[i].height = settings.defaultCellSize;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, num, this.PIECE_MARKED_COLOR);\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, 0);\n            } else {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, undefined);\n            }\n        }\n    }\n\n    /**\n     * Update the size of a cells width and height\n     * @param value height and width to set the piece\n     */\n    setCellSize(value: number) {\n        this.lineWidth = value / this.LINE_WIDTH_DEGREE;\n        this.pieceLength = value - this.lineWidth * 2;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, this.PIECE_MARKED_COLOR);\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    /**\n     * Set the gab size found between pieces\n     * @param value size of gap in pixels\n     */\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    /**\n     * Set the number of cubes that spin inside of invisible pieces\n     * @param value number of spinning cubes found on invisible pieces\n     */\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(0);\n                // new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    /**\n     * Toggle simple render option\n     * @param value property to toggle simple render to\n     */\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    private reverseTiming: boolean = false;\n    /**\n     * Update dynamic pieces (spinning cubes)\n     * return early if simple render is on\n     * @param delta elapsed seconds\n     */\n    update(delta: number) {\n        if (this.simpleRender || this.pieceAnimations.length === 0) {\n            return;\n        }\n        let reverse: boolean[] = [];\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            let index = i;\n            if (this.reverseTiming) {\n                index = this.pieceAnimations.length - i;\n            }\n            const oldTime = this.pieceAnimations[index]\n            const newTime = this.pieceAnimations[index] + (delta * (index) * 1);\n            if (this.reverseTiming) {\n                if (Math.sin(newTime) < Math.sin(oldTime)) {\n                    this.pieceAnimations[index] = newTime;\n                    reverse.push(false);\n                } else {\n                    reverse.push(true);\n                }\n            } else {\n                if (Math.sin(newTime) > Math.sin(oldTime)) {\n                    this.pieceAnimations[index] = newTime;\n                    reverse.push(true);\n                } else {\n                    reverse.push(false);\n                }\n            }\n        }\n        const allSame = reverse.every(b => b === reverse[0]);\n        if (allSame) {\n            this.reverseTiming = !this.reverseTiming;\n        }\n\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        const length = this.pieceLength + (this.lineWidth * 2)\n        ipcContext.clearRect(0, 0, length, length);\n        impcContext.clearRect(0, 0, length, length);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, this.lineWidth, this.lineWidth);\n        this.drawInvisiblePiece(impcContext, this.lineWidth, this.lineWidth, this.PIECE_MARKED_COLOR);\n    }\n\n    /**\n     * Create graphical gird cell without actually providing one\n     * @param ctx canvas context\n     * @param x x position\n     * @param y y position\n     * @param visibility Cell visibility\n     */\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, this.PIECE_MARKED_COLOR); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, this.PIECE_MARKED_COLOR); break;\n        }\n        ctx.restore();\n    }\n\n    /**\n     * Create graphical grid cell\n     * @param ctx canvas\n     * @param cell grid cell\n     * @param x x position\n     * @param y y position\n     */\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                const offset = this.lineWidth / 2;\n                this.drawHover(ctx, x + offset, y + offset);\n                // add this as a debug feature cause its actually cool\n                // const index = this.getIndexByCell(cell);\n                // ctx.drawImage(this.staticPieceCanvas[index], x, y);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    /**\n     * get the index of the cached canvas that matches the cell's state\n     * @param cell Cell\n     */\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    /**\n     * Draw an invisible piece\n     * @param ctx canvas\n     * @param x x position\n     * @param y y pixel position\n     * @param overrideColor color to use instead of default color (#FFF)\n     */\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        if (!this.simpleRender) {\n            ctx.save();\n            let s = this.pieceLength * 0.9;\n            let offset = this.pieceLength * 0.05;\n            for (let i = 1; i < this.pieceAnimations.length + 1; i++) {\n                const rotation =Math.sin(this.pieceAnimations[i]);\n                let index = this.pieceAnimations.length - 1;\n                s += rotation * Math.pow(index, 0.25);\n                offset += (rotation * -Math.pow(index, 0.25)) / 2;\n                this.drawRotatingSquare(ctx, offset + x, y + offset, s, i, rotation, overrideColor);\n                offset += (s / 4) / 2;\n                s = (s / 4) * 3;\n            } \n            ctx.restore();\n        }\n        \n\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawSquare(ctx, x, y, this.pieceLength / this.RECTANGLE_REDIS_DEGREE, this.pieceLength);\n\n        ctx.lineWidth = this.lineWidth;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n    }\n\n    /**\n     * Draw one rotating cube\n     * @param ctx canvas\n     * @param worldX x pixel position\n     * @param worldY y pixel position\n     * @param cellLength spinning cube width\n     * @param i index\n     * @param rotationDirection direction to rotate\n     * @param overrideColor color to use instead of default color (#FFF)\n     */\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotation: number, overrideColor?: string) {\n        const radius = cellLength / this.RECTANGLE_REDIS_DEGREE;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - radius;\n        let y = worldY + cellLength / 4 - radius;\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + + (totalLength / 2), y + totalLength / 2);\n        ctx.rotate(rotation);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawSquare(ctx, x, y, radius, totalLength);\n        let lineWidth = this.pieceLength / this.ROTATING_LINE_WIDTH_DEGREE;\n        if (lineWidth < 1) {\n            lineWidth = 1;\n        }\n        ctx.lineWidth = lineWidth;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.4)\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    /**\n     * Draw a square on the canvas\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     * @param radius border radius\n     * @param length width and height of rectangle\n     */\n    private drawSquare(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    /**\n     * Draw multiple squares at different alpha values to give the appearance of \n     * a gradient\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     */\n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        const gapSize = (this.gapSize / 2)\n        let alpha = 1.0;\n        let step = 1 / gapSize;\n        x += (1 + this.lineWidth) / 2;\n        y += (1 + this.lineWidth) / 2;\n        for (let i = 1; i <= gapSize; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawSquare(ctx, x - i, y - i, (this.pieceLength) / this.RECTANGLE_REDIS_DEGREE,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= step;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    /**\n     * Draw a visible cell that matches the cell value\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     * @param cellValue bomb state value\n     * @param overrideColor color to use instead of default color\n     */\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawSquare(ctx, x, y, this.pieceLength / this.RECTANGLE_REDIS_DEGREE, this.pieceLength);\n            ctx.lineWidth = this.lineWidth;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + (this.lineWidth * 1.5);\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = this.lineWidth;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","import React from 'react';\nimport \"./CheckBox.css\"\n\ninterface Props {\n    text: string;\n    name: string;\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst CheckBox: React.FC<Props> = ({text, name, checked, onChange}) => {\n    return  <label className=\"checkbox\">\n        <input type=\"checkbox\"\n            name={name}\n            checked={checked}\n            onChange={onChange}  />\n            <span>{text}</span>\n    </label>\n}\n\nexport default CheckBox;","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    vibrantColors: boolean;\n    firstMoveHandicap: boolean;\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public firstMoveHandicap: boolean = true;\n\n    @Field(\"settings\")\n    public vibrantColors: boolean = false;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}"],"sourceRoot":""}