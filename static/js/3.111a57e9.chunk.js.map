{"version":3,"sources":["models/GameTypes.ts","logic/BombFinder.ts","util/InSquare.ts","logic/InputController.ts","components/Gameheader.tsx","components/Switch.tsx","components/GameFooter.tsx","components/GameBoard.tsx","pages/game.tsx","components/Button.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","logic/Animation.ts","models/GameBoardTypes.ts","util/Random.ts","logic/BombFinderPieceRenderer.ts","util/toHHMMSS.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js","models/Preferences.ts","assets/hourglass.svg","pages/page-not-found.tsx","assets/piece.svg"],"names":["InputMode","GameStatus","BombFinder","games","settings","minWidth","minHeight","Object","classCallCheck","this","pieceRenderer","grid","updateRemainingPiecesCount","remainingPieces","inputMode","TOGGLE","backgroundAnimation","height","width","offsetWidth","offsetHeight","overflowClasses","BombFinderPieceRenderer","calculatedWidth","calculateBoardSize","calculatedHeight","AnimationTimer","setMarkInput","init","markFlag","arguments","length","undefined","MARK","setTarget","setStep","play","reset","newGame","id","Error","logAndDestroy","delta","isComplete","update","gameHasStarted","totalPieces","calcDelta","time","reduce","total","cell","isVisible","visibility","isBomb","value","invisiblePieces","result","forEach","state","CellState","BOMB","Visibility","VISIBLE","board","events","includes","keys","hover","index","getIndexByPixel","pos","leftClick","INVISIBLE","totalMoves","firstMoveHandicap","repositionBombCell","toggleCell","setCellVisibility","rightClick","isMarkable","MARKED","markCell","_this","newIndex","bombs","area","RandInRange","getNeighbors","cellIndex","console","log","concat","incrementCellValue","objectSpread","pieces","CLEAN","decrementCellValue","constructGrid","neighbors","visited","i","pop","isMarked","push","_this2","neighbor","_this3","pre","VISIBLY_SATISFIED","point","cellSize","gridGapSize","defaultCellSize","row","Math","floor","y","col","x","top","left","square","size","InSquare","getIndex","bombCounter","defaultCell","random","bombProximityCounter","neighborIndex","j","tempRow","tempCol","tempIndex","ctx","canvasWindow","drawBackground","drawBoard","save","gradient1","createLinearGradient","addColorStop","getValue","fillStyle","fillRect","restore","totalPieceSize","startingColOffset","max","startingRowOffset","startingRow","startingCol","endingCol","min","ceil","endingRow","drawPiece","InputController","listeners","timer","touchTimer","touchThreshold","touchPoint","idCounter","previousState","mouseEvent","event","type","buttons","middleClick","pageX","pageY","stopContextMenu","preventDefault","stopPropagation","touchEvent","Date","now","targetTouches","keydownEvent","key","element","uniqueId","listeningTo","pointer","getFunctionPointer","window","addEventListener","passive","rect","getBoundingClientRect","removeEventListener","eventType","GameHeader","props","react_default","a","createElement","className","src","piece","alt","react_router_dom","to","toHHMMSS","hourglass","Switch","checked","onChange","GameFooter","isChecked","isSwitchChecked","info","src_components_Switch","flagToggle","target","GameBoard","stopUpdates","rafId","container","canvas","context2D","gameState","input","ready","gameOver","canVibrate","canTryAgain","toMainMenu","remainingAvailablePiece","changeInputMode","forceUpdate","tryAgain","_callee","newGameId","regenerator_default","wrap","_context","prev","next","sent","setState","t0","warn","stop","goToMainMenu","_callee2","_context2","draw","pollEvents","inputId","handleEvents","viewport","scrollLeft","scrollTop","clientWidth","clientHeight","isGameOver","flush","isGameWon","onGameFinished","navigator","vibrate","getRemainingAvailablePiece","requestAnimationFrame","getTime","prevProps","prevState","destroyGame","createGame","Games","GetById","Preferences","GetPreferences","preferences","page","document","getElementById","getContext","start","gameBoardWidth","gameBoardHeight","innerWidth","vibration","cancelAnimationFrame","react_router","route","Loading","dimensions","canvasBoardClass","gameBoardOverflowClasses","Gameheader","Button","text","onClick","components_GameFooter","isInputModeToggle","Component","Game","to404Page","toWonPage","redirecting","gameFinished","DoesGameExists","match","params","page_not_found","src_components_GameBoard","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","disabled","disabledClass","classes","_defineProperty","obj","defineProperty","enumerable","configurable","writable","d","__webpack_exports__","LoopOptions","step","loop","STOP","_home_divitoa_Program_JS_bombfinder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","playing","alternated","REPEAT","ALTERNATE","v","cv","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","pieceLength","gapSize","simpleRender","exampleCellValue","setSpinningCubes","spinningCubes","drawInvisiblePiece","drawVisibleCell","num","pow","ipcContext","impcContext","clearRect","drawImage","drawHover","getIndexByCell","overrideColor","beginPath","strokeStyle","drawRectangle","lineWidth","stroke","closePath","s","jump","rotation","drawRotatingSquare","worldX","worldY","cellLength","rotationDirection","radius","totalLength","translate","rotate","PI","moveTo","lineTo","quadraticCurveTo","alpha","cellValue","arc","innerX","innerY","gradient","createRadialGradient","fill","font","offset","ypos","xpos","textAlign","textBaseline","fillText","String","hours","minutes","seconds","timeString","_objectSpread","_defineProperty__WEBPACK_IMPORTED_MODULE_0__","source","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","Table","Field","tableName","Query","getById","cachedSettings","timestamp","assign","module","exports","p","r","react_router_dom__WEBPACK_IMPORTED_MODULE_3__","PageNotFound"],"mappings":"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","file":"static/js/3.111a57e9.chunk.js","sourcesContent":["export enum InputMode {\n    TOGGLE,\n    MARK,\n}\n\nexport interface Point2d {\n    x: number;\n    y: number;\n}\n\nexport enum GameStatus {\n    GAME_PAUSED,\n    GAME_PLAY,\n}\n\nexport type GameDifficulty = \"easy\" | \"medium\" | \"hard\" | string;\n\nexport type GameProgress = \"created\" | \"inprogress\" | \"lost\" | \"won\";\n\n","import { Cell, CellState, CellValue, Visibility, isVisible, isBomb, isMarkable, isMarked, incrementCellValue, decrementCellValue } from \"../models/GameBoardTypes\";\nimport { SimpleEventState } from \"../models/EventTypes\";\nimport InSquare from \"../util/InSquare\";\nimport { Point2d, InputMode } from \"../models/GameTypes\";\nimport Games from \"../models/Games\";\nimport { IPreferences } from \"../models/Preferences\";\nimport AnimationTimer from \"./Animation\";\nimport BombFinderPieceRenderer, { CanvasWindow } from \"./BombFinderPieceRenderer\";\nimport RandInRange from \"../util/Random\";\n\nexport default class BombFinder {\n\n    // template data\n    private games: Games;\n    private settings: IPreferences;\n    private pieceRenderer: BombFinderPieceRenderer;\n\n    // game play\n    private grid: Cell[] = [];\n    private updateRemainingPiecesCount: boolean = false;\n    private remainingPieces: number = 0;\n    private inputMode: InputMode = InputMode.TOGGLE;\n\n    // animations\n    private readonly backgroundAnimation: AnimationTimer;\n\n    // canvas data\n    private readonly height: number;\n    private readonly width: number;\n    private readonly offsetWidth: number;\n    private readonly offsetHeight: number;\n    private readonly overflowClasses: string = \"\";\n\n    constructor(games: Games, settings: IPreferences, minWidth: number, minHeight: number) {\n        this.games = games;\n        this.settings = settings;\n        this.pieceRenderer = new BombFinderPieceRenderer(settings);\n\n        const calculatedWidth = this.calculateBoardSize(this.games.width);\n        const calculatedHeight = this.calculateBoardSize(this.games.height);\n\n        if (minWidth > calculatedWidth) {\n            this.width = minWidth;\n            this.offsetWidth = (this.width - calculatedWidth) / 2;;\n        } else {\n            this.overflowClasses += \" overflow-x\"; \n            this.width = calculatedWidth;\n            this.offsetWidth = 0;\n        }\n\n        if (minHeight > calculatedHeight) {\n            this.height = minHeight;\n            this.offsetHeight = (this.height - calculatedHeight) / 2;\n        } else {\n            this.overflowClasses += \" overflow-y\"; \n            this.height = calculatedHeight;\n            this.offsetHeight = 0;\n        }\n        this.backgroundAnimation = new AnimationTimer(121, 3);            \n        this.setMarkInput();\n\n        this.init();\n    }\n\n    public get isInputModeToggle() {\n        return InputMode.TOGGLE === this.inputMode;\n    }\n\n    public get gameBoardOverflowClasses() {\n        return this.overflowClasses;\n    }\n\n    public get gameBoardWidth() {\n        return this.width;\n    }\n\n    public get gameBoardHeight() {\n        return this.height;\n    }\n\n    public get gameState() {\n        return this.games.result;\n    }\n\n    public get isGameOver() {\n        return this.games.result === \"lost\" || this.games.result === \"won\";\n    }\n\n    public get isGameWon() {\n        return this.games.result === \"won\";\n    }\n\n    public get getRemainingAvailablePiece() {\n        return this.remainingPieces;\n    }\n\n    public get getTime() {\n        return Math.floor(this.games.time);\n    }\n\n    public setMarkInput(markFlag: boolean = false) {\n        this.inputMode = (markFlag) ? InputMode.MARK : InputMode.TOGGLE;\n        if (this.inputMode === InputMode.MARK) {\n            this.backgroundAnimation.setTarget(121);\n            this.backgroundAnimation.setStep(3);\n            this.backgroundAnimation.play();\n        } else if (this.inputMode === InputMode.TOGGLE) {\n            this.backgroundAnimation.setTarget(0);\n            this.backgroundAnimation.setStep(-3);\n            this.backgroundAnimation.play();\n        }\n    }\n\n    public async reset(): Promise<string> {\n        const newGame = await this.games.reset(this.games);\n        if (newGame) {\n            return newGame.id;\n        }\n        throw new Error(\"Had a problem saving old Game\");\n    }\n\n    public async logAndDestroy() {\n        return await this.games.logAndDestroy();\n    }\n\n    public update(delta: number) {\n        if (this.games.isComplete) {\n            return;\n        }\n        this.pieceRenderer.update(delta);\n        this.backgroundAnimation.update(delta);\n        if (this.games.gameHasStarted && this.remainingPieces !== this.games.totalPieces) {\n            const calcDelta = delta;\n            this.games.time += calcDelta;\n        }\n        if (this.updateRemainingPiecesCount) {\n            this.remainingPieces = this.grid.reduce((total, cell) =>\n                (isVisible(cell.visibility) && !isBomb(cell.value)) ? total - 1 : total\n            , this.games.totalPieces);\n            this.updateRemainingPiecesCount = false;\n            this.games.invisiblePieces = this.remainingPieces;\n            this.games.update();\n        }\n        if (!this.games.isComplete && (this.games.result === \"lost\" || this.remainingPieces === 0)) {\n            this.grid.forEach((cell) => {\n                if (cell.state === CellState.BOMB) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n            this.games.board = this.grid;\n            if (this.games.result === \"lost\") {\n                this.games.result = \"lost\";\n                this.games.update();\n            }\n            else if (this.remainingPieces === 0) {\n                this.games.result = \"won\";\n                this.games.update();\n            }\n            this.games.isComplete = true;\n        }\n    }\n\n    public handleEvents(events?: SimpleEventState) {\n        if (this.games.result !== \"inprogress\" && this.games.result !== \"created\") {\n            return;\n        }\n        if (!events) {\n            return;\n        }\n        if (events.events.includes(\"keydown\")) {\n            if (events.keys.includes(\"f\")) {\n                this.setMarkInput(this.inputMode === InputMode.TOGGLE);\n            }\n        }\n        if (events.events.includes(\"mousemove\")) {\n            this.grid.forEach((cell) => {\n                cell.hover = false;\n            });\n            const index = this.getIndexByPixel(events.pos);\n            if (index !== null && index < this.grid.length && this.grid[index]) {\n                this.grid[index].hover = true;\n            }\n        }\n        if (events.events.includes(\"mousedown\") || events.events.includes(\"touch\")) {\n            this.games.result = \"inprogress\";\n            const index = this.getIndexByPixel(events.pos);\n            if (index === null || index >= this.grid.length) {\n                return;\n            }\n            let cell = this.grid[index];\n            if (this.inputMode === InputMode.TOGGLE && events.leftClick && cell.visibility === Visibility.INVISIBLE) {\n                this.games.totalMoves++;\n                if (isBomb(cell.value) && this.remainingPieces === this.games.totalPieces\n                    && this.settings.firstMoveHandicap) {\n                    // it is impossible to lose on the first move, so move the\n                    // bomb somewhere else\n                    this.repositionBombCell(index);\n                    cell = this.grid[index];\n                } else if (isBomb(cell.value)) {\n                    this.games.result = \"lost\";\n                }\n                if (cell.value === 0) {\n                    this.toggleCell(index);\n                }\n                this.setCellVisibility(index);\n            } else if (events.rightClick || (events.leftClick && this.inputMode === InputMode.MARK)) {\n                this.games.totalMoves++;\n                if (isMarkable(cell.visibility)) {\n                    cell.visibility = (cell.visibility === Visibility.MARKED)\n                        ? Visibility.INVISIBLE\n                        : Visibility.MARKED;\n                    this.markCell(index);\n                }\n            }\n            this.updateRemainingPiecesCount = true;\n        }\n        if (this.games.result === \"lost\") {\n            this.grid.forEach((cell) => {\n                if (isBomb(cell.value)) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n        }\n    }\n\n    /**\n     * Bomb was clicked on the first turn, therefore we need to re-position the\n     * bomb and calculate the index pieces value\n     *\n     * @param index position of cell inside grid\n     */\n    private repositionBombCell(index: number) {\n        // reposition bomb\n        // check the density of bombs on the board. if the board is too dense\n        // place the new bomb at the first non-bomb tile\n        let newIndex = 0;\n        if ((this.games.bombs / this.games.area) > 0.75) {\n            while (isBomb(this.grid[newIndex].value)) { newIndex++; }\n        } else {\n            do {\n                newIndex = RandInRange(0, this.grid.length - 1);\n            // we don't need to check if the piece is already visible because\n            // no pieces on the board are currently visible\n            } while (isBomb(this.grid[newIndex].value));\n        }\n        this.grid[newIndex] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.BOMB,\n            value: null\n        };\n        const neighbors = this.getNeighbors(newIndex);\n        // update all the neighbors that are not bombs\n        neighbors.forEach( cellIndex => {\n            if (isBomb(this.grid[cellIndex].value)) {\n                return;\n            }\n            console.log(`incrementing ${cellIndex} from ${this.grid[cellIndex].value} to ${incrementCellValue(this.grid[cellIndex].value)}`)\n            this.grid[cellIndex] = {\n                ...this.grid[cellIndex],\n                ...{ value: incrementCellValue(this.grid[cellIndex].value)}\n            };\n        });\n        // create the new cell\n        const pieces = this.getNeighbors(index);\n        const bombs = pieces.reduce((bombs, index) =>\n            isBomb(this.grid[index].value) ? bombs + 1 : bombs\n        , 0);\n        this.grid[index] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.CLEAN,\n            value: bombs as CellValue\n        };\n        // we also need to decrement all of the neighbors\n        pieces.forEach( cellIndex => {\n            if (isBomb(this.grid[cellIndex].value)) {\n                return;\n            }\n            console.log(`decrementing ${cellIndex} from ${this.grid[cellIndex].value} to ${decrementCellValue(this.grid[cellIndex].value)}`)\n            this.grid[cellIndex] = {\n                ...this.grid[cellIndex],\n                ...{ value: decrementCellValue(this.grid[cellIndex].value) }\n            }\n        });\n    }\n\n    protected init() {\n        this.remainingPieces = this.games.invisiblePieces;\n        if (this.games.board.length === 0) {\n            this.grid = this.constructGrid();\n            this.games.board = this.grid;\n        }\n        else {\n            this.grid = this.games.board;\n        }\n    }\n\n    private toggleCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        const visited: number[] = [index];\n        while (neighbors.length > 0) {\n            const i = neighbors.pop()!;\n            if (this.grid[i].value === 0 && !isMarked(this.grid[i])) {\n                const newNeighbors = this.getNeighbors(i);\n                newNeighbors.forEach((newIndex) => {\n                    if (!neighbors.includes(newIndex) && !visited.includes(newIndex)) {\n                        neighbors.push(newIndex);\n                    }\n                });\n            }\n            this.setCellVisibility(i);\n            visited.push(i);\n        }\n    }\n\n    private markCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        neighbors.forEach((neighbor) => {\n            const cell = this.grid[neighbor];\n            if (isVisible(cell.visibility) && !isBomb(cell.value) && cell.value !== 0) {\n                this.setCellVisibility(neighbor);\n            }\n        });\n    }\n\n    private setCellVisibility(index: number) {\n        if (isMarked(this.grid[index])) {\n            return;\n        }\n        if (this.grid[index].value === null || this.grid[index].value === 0) {\n            this.grid[index].visibility = Visibility.VISIBLE;\n            return;\n        }\n        const neighbor = this.getNeighbors(index);\n        const count = neighbor.reduce((pre, index) => {\n            const cell = this.grid[index];\n            if (cell.visibility === Visibility.MARKED) {\n                return pre + 1;\n            }\n            return pre;\n        }, 0);\n        if (count >= this.grid[index].value!) {\n            this.grid[index].visibility = Visibility.VISIBLY_SATISFIED\n        } else {\n            this.grid[index].visibility = Visibility.VISIBLE;\n        }\n    }\n\n    private getIndexByPixel(point: Point2d): number | null {\n        const cellSize = this.settings.gridGapSize + this.settings.defaultCellSize;\n        const row = Math.floor((point.y - this.offsetHeight) / cellSize);\n        const col = Math.floor((point.x - this.offsetWidth) / cellSize);\n\n        // check if pointer is inside square\n        const top =  this.offsetHeight + ((row * cellSize) + this.settings.gridGapSize);\n        const left = this.offsetWidth + ((col * cellSize) + this.settings.gridGapSize);\n\n        if (row >= 0 && col >= 0 && col < this.games.width && row < this.games.height &&\n            InSquare({top, left, size: this.settings.defaultCellSize }, point)) {\n            return this.getIndex(row, col);\n        }\n        return null;\n    }\n\n    private getIndex(row: number, col: number): number {\n        return (row * this.games.width) + col;\n    }\n\n    private constructGrid(): Cell[] {\n        const grid: Array<Cell | null> = [];\n\n        // create the grid\n        for (let i = 0; i < this.games.area; i++) {\n            grid.push(null);\n        }\n\n        // place the bombs\n        let bombCounter = this.games.bombs;\n        while (bombCounter > 0) {\n            const defaultCell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.BOMB,\n            }\n            const index = Math.floor(Math.random() * this.games.area);\n\n            if (grid[index] === null) {\n                bombCounter--;\n                grid[index] = defaultCell;\n            }\n        }\n\n        // place safe spaces\n        for (let index = 0; index < grid.length; index++) {\n            if (grid[index] !== null) { // if this is a bomb\n                continue;\n            }\n\n            let bombProximityCounter = 0;\n            const neighbors = this.getNeighbors(index);\n            for (let i = 0; i < neighbors.length; i++) {\n                const neighborIndex = neighbors[i];\n                if (grid[neighborIndex] !== null && grid[neighborIndex]!.state === CellState.BOMB) {\n                    bombProximityCounter++;\n                }\n            }\n            const cell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.CLEAN,\n                value: bombProximityCounter as CellValue,\n            };\n            grid[index] = cell;\n        }\n\n        return grid as Cell[];\n    }\n\n    private getNeighbors(index: number): number[] {\n        if (index < 0 || index >= this.games.area) {\n            return [];\n        }\n        const row = Math.floor(index / this.games.width);\n        const col = index % this.games.width;\n        const neighbors = [];\n        for (let j = 0; j < 8; j++) {\n            let tempRow = row;\n            let tempCol = col;\n            switch (j) {\n                case 0:\n                    tempRow -= 1;\n                    tempCol -= 1;\n                    break;\n                case 1: tempRow -= 1; break;\n                case 2:\n                    tempRow -= 1;\n                    tempCol += 1;\n                    break;\n                case 3: tempCol -= 1; break;\n                case 4: tempCol += 1; break;\n                case 5:\n                    tempRow += 1;\n                    tempCol -= 1;\n                    break;\n                case 6: tempRow += 1; break;\n                case 7:\n                    tempRow += 1;\n                    tempCol += 1;\n                    break;\n            }\n            const tempIndex = this.getIndex(tempRow, tempCol);\n            if (tempRow >= 0 && tempRow < this.games.height && // check if the index is in the gird\n                tempCol >= 0 && tempCol < this.games.width) {\n                neighbors.push(tempIndex);\n            }\n        }\n        \n        return neighbors;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        // TODO: futher optimizations \n        // TODO: Render screen differences only, not the whole new state.\n        this.drawBackground(ctx);\n        this.drawBoard(ctx, canvasWindow);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        const gradient1 = ctx.createLinearGradient(this.width / 2,\n            this.height, this.width / 2, 0);\n        gradient1.addColorStop(0.05, '#333');\n        gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 50%, 1)`);\n        ctx.fillStyle = gradient1;\n        ctx.fillRect(0, 0, this.width, this.height);\n        ctx.restore();\n    }\n\n    private drawBoard(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        const totalPieceSize = this.settings.defaultCellSize + this.settings.gridGapSize;\n        const startingColOffset = Math.max(this.width, canvasWindow.width) - canvasWindow.width;\n        const startingRowOffset = Math.max(this.height, canvasWindow.height) - canvasWindow.height;\n\n        const startingRow = Math.floor(canvasWindow.x / (totalPieceSize + startingColOffset + 1));\n        const startingCol = Math.floor(canvasWindow.y / (totalPieceSize + startingRowOffset + 1));\n\n        const endingCol = Math.min(Math.ceil(\n            (canvasWindow.x + canvasWindow.width - this.offsetWidth) / totalPieceSize) + 1,\n            this.games.width);\n        const endingRow = Math.min(Math.ceil(\n            (canvasWindow.y + canvasWindow.height - this.offsetHeight) / totalPieceSize) + 1,\n            this.games.height);\n\n        for (let row = startingRow; row < endingRow; row++) {\n            for (let col = startingCol; col < endingCol; col++) {\n                // position\n                const x = this.offsetWidth + this.calculateBoardSize(col);\n                const y = this.offsetHeight + this.calculateBoardSize(row);\n                const index = this.getIndex(row, col);\n                const cell = this.grid[index];\n\n                /**\n                 * This is what I want to be able to call\n                 */\n                if (cell) {\n                    this.pieceRenderer.drawPiece(ctx, cell, x, y);\n                }\n            }    \n        }\n    }\n\n    private calculateBoardSize(size: number) {\n        return (size * this.settings.defaultCellSize) + ((size + 1) * this.settings.gridGapSize)\n    }\n}\n","import { Point2d } from \"../models/GameTypes\";\n\nexport default function InSquare(square: {\n    top: number,\n    left: number,\n    size: number,\n}, point: Point2d): boolean {\n    return point.y >= square.top && point.y <= square.top + square.size &&\n        point.x >= square.left && point.x <= square.left + square.size\n}","import { SimpleEventState } from \"../models/EventTypes\";\nimport { Point2d } from \"../models/GameTypes\";\n\ninterface Listener {\n    element: HTMLElement;\n    listeningTo: Array<keyof HTMLElementEventMap>;\n}\n\n// why not use\n// https://reactjs.org/docs/events.html#pointer-events\nexport default class InputController {\n\n    private listeners: { [key: number]: Listener } = {};\n    private timer: number = 0;\n    private touchTimer: number = 0;\n    private touchThreshold: number = 300;\n    private touchPoint?: Point2d;\n    private idCounter: number = 0;\n\n    private state?: SimpleEventState;\n    private previousState?: SimpleEventState;\n\n    /**\n     * Place event listeners on a html element\n     * \n     * @param {HTMLElement} element element events to be placed on\n     * @param {String[]} events events to subscribe to\n     * @returns {number} id that tracks your current input session\n     */\n    public start(element: HTMLElement, events: Array<keyof HTMLElementEventMap>): number {\n        // add to listeners\n        const id = this.uniqueId();\n        this.listeners[id] = {\n            element,\n            listeningTo: []\n        };\n\n        events.forEach((event) => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.addEventListener(event, pointer as any);\n            }\n            else {\n                this.listeners[id].element.addEventListener(event, pointer as any, {\n                    passive: event !== \"contextmenu\",\n                });\n            }\n            this.listeners[id].listeningTo.push(event);\n        });\n\n        return id;\n    }\n\n    /**\n     * Get all event that happened\n     * \n     * Remember to call flush() or else you will get old events that persisted\n     * between frames\n     * \n     * @param {number} id - The events binded to the element you want\n     * @returns {Point2d | null} returns mouses new position or null if the \n     *      mouse hasn't moved since last checked\n     */\n    public pollEvents(id: number): SimpleEventState | undefined {\n        if (this.state) {\n            const rect = this.listeners[id].element.getBoundingClientRect();\n            this.state.pos.x -= rect.left;\n            this.state.pos.y -= rect.top;\n        }\n        return this.state;\n    }\n\n    /**\n     * Remove all of the input state from the controller\n     * @returns {void} \n     */\n    public flush() {\n        this.previousState = this.state;\n        this.state = undefined;\n    }\n\n    public stop(id: number): boolean {\n        if (this.listeners[id] === undefined) {\n            return false;\n        }\n\n        this.listeners[id].listeningTo.forEach(event => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.removeEventListener(event, pointer as any);\n            } else {\n                this.listeners[id].element.removeEventListener(event, pointer as any);\n            }\n        });\n\n        return true;\n    }\n\n    private getFunctionPointer(eventType: keyof HTMLElementEventMap) {\n        switch (eventType) {\n            case \"mousemove\": return this.mouseEvent;\n            case \"mousedown\": return this.mouseEvent;\n            case \"mouseup\": return this.mouseEvent;\n            case \"contextmenu\": return this.stopContextMenu;\n            case \"touchstart\": return this.touchEvent;\n            case \"touchmove\": return this.touchEvent;\n            case \"touchend\": return this.touchEvent;\n            case \"keydown\": return this.keydownEvent;\n        }\n    }\n\n    private mouseEvent = (event: MouseEvent) => {\n        if (this.previousState && this.previousState.events.includes(\"touch\")) {\n            // this means touch is active\n            return;\n        }\n        if (this.state && this.state.events.includes(\"touch\")) {\n            return;\n        }\n\n        // because state already exists, we need to add new data types\n        // this is because if a mousemove happens first then a mousedown event\n        // happens, the left, middle, and right click events won't update\n        if (this.state) {\n            this.state.events.push(event.type as any);\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousemove\") {\n            this.state.pos = {\n                x: event.pageX,\n                y: event.pageY,\n            };\n            return;\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousedown\") {\n            this.state.leftClick = [1, 3, 5, 7].includes(event.buttons);\n            this.state.middleClick = [4, 5, 6, 7].includes(event.buttons);\n            this.state.rightClick = [2, 3, 6, 7].includes(event.buttons);\n            return;\n        }\n        // state has not been initialized so create it.\n        this.state = {\n            leftClick:   [1, 3, 5, 7].includes(event.buttons),\n            rightClick:  [2, 3, 6, 7].includes(event.buttons),\n            middleClick: [4, 5, 6, 7].includes(event.buttons),\n            pos: {\n                x: event.pageX,\n                y: event.pageY,\n            },\n            keys: [],\n            events: [event.type as any]\n        };\n    }\n\n    private stopContextMenu = (event: any) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    }\n\n    private touchEvent = (event: TouchEvent) => {\n        if (event.type === \"touchstart\") {\n            if (this.touchTimer === 0) {\n                this.timer = Date.now();\n            }\n            this.touchPoint = {\n                x: event.targetTouches[0].pageX,\n                y: event.targetTouches[0].pageY,\n            };\n            return;\n        }\n\n        if (event.type === \"touchmove\") {\n            this.touchPoint = undefined;\n            return;\n        }\n\n        if (event.type === \"touchend\" && this.touchPoint) {\n            const delta = Date.now() - this.timer;\n            this.timer = Date.now();\n            this.touchTimer += delta;\n            this.state = {\n                leftClick: this.touchTimer < this.touchThreshold,\n                middleClick: false,\n                rightClick: this.touchTimer > this.touchThreshold,\n                pos: this.touchPoint!,\n                keys: (this.state) ? this.state!.keys : [],\n                events: [\"touch\"]\n            }\n            this.touchPoint = undefined;\n            this.touchTimer = 0;\n        }\n    }\n\n    private keydownEvent = (event: KeyboardEvent) => {\n        if(this.state) {\n            this.state.events.push(event.type as any);\n        }\n        if (this.state) {\n            this.state.keys.push(event.key);\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1 },\n                keys: [event.key],\n                events: [event.type as any]\n            };\n        }\n    }\n\n    private uniqueId() {\n        return this.idCounter++;\n    }\n}\n","import React from 'react';\nimport toHHMMSS from '../util/toHHMMSS';\nimport piece from \"../assets/piece.svg\";\nimport hourglass from \"../assets/hourglass.svg\";\nimport \"./Header.css\"\nimport { Link } from 'react-router-dom';\n\ninterface Props {\n    time: number;\n    left: number;\n    pieces: number;\n}\n\nconst GameHeader: React.FC<Props> = (props: Props) => {\n    return <header className=\"header  header--game\">\n        <div className=\"header__detail\" >\n            <img src={piece} alt=\"Home\" />\n            <span>{props.left}/{props.pieces}</span>\n        </div>\n        <h3>\n            <Link to=\"/\">BombFinder</Link>\n        </h3>\n        <div className=\"header__detail\">\n            <span>{toHHMMSS(props.time)}</span>\n            <img src={hourglass} alt=\"Home\" />\n        </div>\n    </header>\n}\n\nexport default GameHeader;","import React from 'react';\nimport \"./Switch.css\";\n\ninterface Props {\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Switch: React.FC<Props> = (props: Props) => {\n    return <label className=\"switch\">\n        <input\n            checked={props.checked}\n            onChange={props.onChange}\n            className=\"switch__input\"\n            type=\"checkbox\" />\n        <span className=\"switch__box\">\n            <span className=\"switch__marker\" />\n        </span>\n    </label>\n}\n\nexport default Switch;","import React from 'react';\nimport info from \"../assets/info.svg\";\nimport settings from \"../assets/cog-f.svg\";\nimport { Link } from 'react-router-dom';\nimport \"./Footer.css\"\nimport Switch from './Switch';\n\ninterface Props {\n    isSwitchChecked?: boolean;\n    flagToggle: (value: boolean) => void;\n}\n\nconst GameFooter: React.FC<Props> = (props: Props) => {\n    const isChecked = (props.isSwitchChecked) ? true : false;\n    return (\n        <footer className=\"footer footer--game\">\n            <Link to=\"/how-to-play\">\n                <img src={info} alt=\"Info\" />\n            </Link>\n            <div className=\"footer__text\">\n                <span>Clear</span>\n                <Switch\n                    checked={isChecked}\n                    onChange={(event: any) => props.flagToggle(event.target.checked) }/>\n                <span>Flag</span>\n            </div>\n            <Link to=\"/settings\">\n                <img src={settings} alt=\"Settings\" />\n            </Link>\n        </footer>\n    );\n}\n\nexport default GameFooter;","import React, { Component } from 'react';\nimport BombFinder from \"../logic/BombFinder\";\nimport InputController from \"../logic/InputController\";\nimport { Redirect } from 'react-router-dom';\nimport { GameProgress } from '../models/GameTypes';\nimport { CanvasWindow } from '../logic/BombFinderPieceRenderer';\nimport Games from '../models/Games';\nimport Loading from './Loading';\nimport Preferences from '../models/Preferences';\nimport Button from './Button';\nimport GameHeader from './Gameheader';\nimport GameFooter from './GameFooter';\nimport './GameBoard.css';\n\ninterface Props {\n    id: string;\n    onGameFinished: (result: GameProgress) => void\n}\n\ninterface State {\n    ready: boolean;\n    gameOver: boolean;\n    canVibrate: boolean;\n    canTryAgain: boolean;\n    toMainMenu: boolean;\n    totalPieces: number;\n    remainingAvailablePiece: number;\n    newGameId?: string;\n    inputId?: number;\n    time: number;\n}\n\nclass GameBoard extends Component<Props, State> {\n\n    private stopUpdates: boolean = false;\n    private rafId?: number;\n\n    private container?: HTMLDivElement;\n    private canvas?: HTMLCanvasElement;\n    // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#Turn_off_transparency\n    private context2D?: CanvasRenderingContext2D;\n    private gameState?: BombFinder;\n    private input?: InputController;\n\n    state: Readonly<State> = {\n        ready: false,\n        gameOver: false,\n        canVibrate: false,\n        canTryAgain: false,\n        toMainMenu: false,\n        totalPieces: 0,\n        remainingAvailablePiece: 0,\n        time: 0,\n    }\n\n    public componentDidUpdate(prevProps: Props, prevState: State) {\n        if (prevState.newGameId && prevProps.id !== prevState.newGameId) {\n            // new game has started without unmounting the component\n            this.setState({\n                ready: false,\n                gameOver: false,\n                canTryAgain: false,\n                time: 0,\n                newGameId: undefined,\n                inputId: undefined,\n            });\n            this.destroyGame();\n            this.createGame();\n        }\n    }\n\n    public async componentDidMount() {\n        this.createGame();\n    }\n\n    public componentWillUnmount() {\n        this.stopUpdates = true;\n        this.destroyGame();\n    }\n\n    public async createGame() {\n        // TODO: GetById error handling\n        const games = await Games.GetById(this.props.id)!;\n        const preferences = await Preferences.GetPreferences();\n        const page = document.getElementById(\"page\") as HTMLDivElement;\n        if (games.result === \"won\") {\n            this.props.onGameFinished(games.result);\n            return;\n        }\n        // TODO: Remove magic number\n        this.gameState = new BombFinder(games, preferences, page.clientWidth, page.clientHeight - 120);\n        this.input = new InputController();\n        this.setState({\n            ready: true,\n            totalPieces: games.totalPieces,\n            remainingAvailablePiece: this.gameState.getRemainingAvailablePiece\n        });\n        this.canvas = document.getElementById(\"board\") as HTMLCanvasElement;\n        this.container = document.getElementById(\"board-container\") as HTMLDivElement;\n        this.context2D = this.canvas.getContext(\"2d\")!;\n\n        const inputId = this.input.start(this.canvas!, [\"mousemove\", \"mousedown\",\n            \"contextmenu\", \"touchstart\", \"touchmove\", \"touchend\", \"keydown\"]); \n        // TODO: Add error handling\n        this.canvas!.width = this.gameState!.gameBoardWidth;\n        this.canvas!.height = this.gameState!.gameBoardHeight;\n        this.container.scrollLeft = (this.gameState!.gameBoardWidth - window.innerWidth) / 2;\n        this.setState({ ready: true, inputId: inputId, canVibrate: preferences.vibration });\n        requestAnimationFrame(this.draw);\n    }\n\n    public destroyGame() {\n        if (this.state.ready && this.state.inputId) {\n            this.input!.stop(this.state.inputId!);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId!);\n        }\n    }\n\n    public changeInputMode = (markFlag: boolean) => {\n        this.gameState!.setMarkInput(markFlag);\n        this.forceUpdate();\n    }\n\n    public tryAgain = async () => {\n        if (this.state.ready && !this.state.newGameId && this.state.canTryAgain) {\n            try {\n                const newGameId = await this.gameState!.reset();\n                this.setState({ ready: false, newGameId });\n            } catch (e) {\n                console.warn(\"error \" + e);\n                // TODO: implement Error handling\n            }\n        }\n    }\n\n    public goToMainMenu = async () => {\n        if (this.state.ready) {\n            const logged = await this.gameState!.logAndDestroy();\n            if (logged) {\n                this.setState({toMainMenu: true});\n            }\n        }\n    }\n\n    public render() {\n        if (this.state.toMainMenu) {\n            return <Redirect to=\"/\" />;\n        }\n        if (this.state.newGameId) {\n            const route = `/game/${this.state.newGameId}`;\n            return <Redirect to={route} />;\n        }\n        if (!this.state.ready) {\n            return <Loading />\n        }\n        const dimensions = {\n            height: this.gameState!.gameBoardHeight,\n            width: this.gameState!.gameBoardWidth,\n        };\n        let canvasBoardClass = \"board__canvas \" + this.gameState!.gameBoardOverflowClasses;\n        return (\n            <div className=\"board\">\n                <GameHeader time={this.gameState!.getTime}\n                    left={this.state.remainingAvailablePiece}\n                    pieces={this.state.totalPieces}/>\n                <div className={canvasBoardClass} id=\"board-container\">\n                    <canvas id=\"board\"\n                        className={this.gameState!.gameState}\n                        width={dimensions.width}\n                        height={dimensions.height} />\n                    {(this.state.gameOver)\n                        ? <div className=\"board__popup\">\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Try Again\"\n                                onClick={this.tryAgain} />\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Main Menu\"\n                                onClick={this.goToMainMenu} />\n                        </div>\n                        : null\n                    }\n                </div>\n                <GameFooter\n                    isSwitchChecked={!this.gameState!.isInputModeToggle}\n                    flagToggle={this.changeInputMode} />\n            </div>\n        );\n    }\n\n    private draw = () => {\n        if (!this.state.ready) {\n            // TODO: do we need this ready check for the game?????\n            return;\n        }\n        const elapsedTime = 0.0167;\n        const events = this.input!.pollEvents(this.state.inputId!);\n        \n        if (events) {\n            this.gameState!.handleEvents(events);\n            if (events.keys.length > 0) {\n                this.forceUpdate();\n            }\n        }\n        this.gameState!.update(elapsedTime);\n        // TODO: calculate playing area and send it to draw\n        const viewport: CanvasWindow = {\n            x: this.container!.scrollLeft, y: this.container!.scrollTop,\n            width: this.container!.clientWidth, height: this.container!.clientHeight\n        };\n        this.gameState!.draw(this.context2D!, viewport);\n        \n        // Initial draw call before any events\n        if (this.rafId === undefined || this.gameState!.isGameOver) {\n            this.gameState!.draw(this.context2D!, viewport);\n        }\n        \n        this.input!.flush();\n        \n        \n        if (this.gameState!.isGameOver) {\n            if (this.gameState!.isGameWon) {\n                this.props.onGameFinished(\"won\");\n            } else {\n                if (this.state.canVibrate && navigator.vibrate) {\n                    navigator.vibrate(200);\n                }\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    gameOver: true,\n                    canVibrate: false,\n                    canTryAgain: true,\n                });\n            }\n        }\n\n        if (!this.stopUpdates) {\n            this.rafId = requestAnimationFrame(this.draw);\n            if (this.state.time !== this.gameState!.getTime) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    time: this.gameState!.getTime\n                });\n            } else if (this.state.remainingAvailablePiece !== this.gameState!.getRemainingAvailablePiece) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece\n                });\n            }\n        }\n    }\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport { GameProgress } from '../models/GameTypes';\nimport GameBoard from '../components/GameBoard';\nimport { RouteComponentProps, Redirect } from 'react-router';\nimport Games from '../models/Games';\nimport PageNotFound from './page-not-found';\n\ninterface ParamProps {\n    id: string;\n}\n\ntype Props = RouteComponentProps<ParamProps>;\n\ninterface State {\n    // for when the game is done\n    to404Page: boolean;\n    toWonPage: boolean;\n    redirecting: boolean;\n    ready: boolean;\n}\n\nexport default class Game extends Component<Props, State> {\n\n    state: Readonly<State> = {\n        to404Page: false,\n        toWonPage: false,\n        redirecting: false,\n        ready: false,\n    }\n\n    async componentDidMount() {\n        const exists = await Games.DoesGameExists(this.props.match.params.id);\n        if (exists) {\n            this.setState({ to404Page: false, ready: true });\n        }\n        else {\n            this.setState({ to404Page: true, ready: true });\n        }\n    }\n\n    gameFinished = (result: GameProgress) => {\n        this.setState({ toWonPage: result === \"won\" });\n    }\n\n    public render() {\n        if (this.state.toWonPage) {\n            return <Redirect to={`/game/${this.props.match.params.id}/game-won`} />\n        }\n        else if (this.state.to404Page) {\n            return <PageNotFound />;\n        }\n        else if (this.state.ready) {\n            return <GameBoard\n                id={this.props.match.params.id}\n                onGameFinished={this.gameFinished} />\n        } else {\n            return null;\n        }\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","\nexport enum LoopOptions {\n    REPEAT,\n    ALTERNATE,\n    STOP\n}\n\nexport default class AnimationTimer {\n\n    private playing: boolean;\n    private timer = 0;\n    private target: number;\n    private step: number;\n    private loop: LoopOptions;\n    private alternated: boolean;\n\n    constructor(target: number, step: number, loop: LoopOptions = LoopOptions.STOP) {\n        this.timer = 0;\n        this.target = target;\n        this.step = step;\n        this.loop = loop;\n        this.alternated = false;\n        this.playing = true;\n    }\n\n    update(delta: number) {\n        if (!this.isComplete() && this.playing) {\n            this.timer += this.step;\n        } else {\n            if (this.loop === LoopOptions.REPEAT) {\n                this.timer = this.timer % this.target;\n            } else if (this.loop === LoopOptions.ALTERNATE) {\n                this.setStep(this.step * -1);\n                if (!this.alternated) {\n                    this.timer = 0;\n                } else {\n                    this.timer = this.target;\n                }\n            } else if (this.loop === LoopOptions.STOP) {\n                this.timer = this.target;\n                this.stop();\n            }\n        }\n    }\n\n    public stop() {\n        this.playing = false;\n    }\n\n    public play() {\n        this.playing = true;\n    }\n\n    public getValue() {\n        return this.timer;\n    }\n\n    public setTarget(target: number) {\n        this.target = target;\n    }\n\n    public setStep(step: number) {\n        if (step < 0) {\n            this.alternated = true;\n        } else {\n            this.alternated = false;\n        }\n        this.step = step;\n    }\n\n    public isComplete() {\n        return (this.alternated)\n            ? this.timer <= 0\n            : this.timer >= this.target;\n    }\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const incrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        case 3: return 4;\n        case 4: return 5;\n        case 5: return 6;\n        case 6: return 7;\n        case 7: return 8;\n        // these last 2 cases should rarely be called\n        case 8: return 8;\n        default: return null\n    }\n}\n\nexport const decrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 1: return 0;\n        case 2: return 1;\n        case 3: return 2;\n        case 4: return 3;\n        case 5: return 4;\n        case 6: return 5;\n        case 7: return 6;\n        case 8: return 7;\n        // these last 2 cases should rarely be called\n        case 0: return 0;\n        default: return null\n    }\n}\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import AnimationTimer, { LoopOptions } from \"./Animation\";\nimport { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    private pieceAnimations: AnimationTimer[] = [];\n\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.pieceLength = settings.defaultCellSize;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = this.pieceLength + 2;\n        this.invisiblePieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, 1, 1);\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = this.pieceLength + 2;\n        this.invisibleMarkedPieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, 1, 1, \"#3396ff\");\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = this.pieceLength + 2;\n            this.staticPieceCanvas[i].height = this.pieceLength + 2;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 1, 1.5, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 1, 1.5, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 1, 1.5, 0);\n            } else {\n                this.drawVisibleCell(ctx, 1, 1.5, undefined);\n            }\n        }\n    }\n\n    setCellSize(value: number) {\n        this.pieceLength = value;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(\n                new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    update(delta: number) {\n        if (this.simpleRender) {\n            return;\n        }\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            this.pieceAnimations[i].update(delta);\n        }\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        ipcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        impcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, 1, 1);\n        this.drawInvisiblePiece(impcContext, 1, 1, \"#3396ff\");\n    }\n\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, \"#3396ff\"); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, \"#3396ff\"); break;\n        }\n        ctx.restore();\n    }\n\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                this.drawHover(ctx, x + 1, y + 1);\n                // add this as a debug feature cause its actually cool\n                // const index = this.getIndexByCell(cell);\n                // ctx.drawImage(this.staticPieceCanvas[index], x, y);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n\n        if (this.simpleRender) {\n            return;\n        }\n\n        ctx.save();\n        let s = this.pieceLength;\n        let jump = 0;\n        for (let i = 1; i < this.pieceAnimations.length; i++) {\n            const rotation = (i % 2 === 0) ? 1 : -1;\n            this.drawRotatingSquare(ctx, jump + x, jump + y, s, i, rotation, overrideColor);\n            jump += (s / 4) / 2;\n            s = (s / 4) * 3;\n        }\n        ctx.restore();\n    }\n\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotationDirection: 1 | -1, overrideColor?: string) {\n        const radius = cellLength / 8;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - (radius);\n        let y = worldY + cellLength / 4 - (radius);\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + totalLength / 2, y + totalLength / 2);\n        ctx.rotate(this.pieceAnimations[i].getValue() *  Math.PI / 180);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawRectangle(ctx, x, y, radius, totalLength);\n        ctx.lineWidth = 2;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"gray\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    private drawRectangle(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        let alpha = 1.0;\n        for (let i = 1; i <= (this.gapSize / 2); i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawRectangle(ctx, x - i, y - i, (this.pieceLength) / 8,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= 0.1;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + 2;\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = 2;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","export default function toHHMMSS(time: number) {\n    time = Math.floor(time);\n    const hours = Math.floor(time / 3600);\n    const minutes = Math.floor((time - (hours * 3600)) / 60);\n    const seconds = time - (hours * 3600) - (minutes * 60);\n    let timeString = \"\";\n\n    if (hours > 0) {\n        timeString += (hours < 10) ? `0${hours}:` : `${hours}:`;\n    }\n    timeString += (minutes < 10) ? `0${minutes}:` : `${minutes}:`;\n    timeString += (seconds < 10) ? `0${seconds}` : `${seconds}`;\n\n    return timeString;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    firstMoveHandicap: boolean;\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public firstMoveHandicap: boolean = true;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}","module.exports = __webpack_public_path__ + \"static/media/hourglass.63a5448b.svg\";","import React from 'react';\nimport \"../components/Button.css\"\nimport \"./page-not-found.css\"\nimport { Link } from 'react-router-dom';\n\nconst PageNotFound: React.FC = () => {\n    return <div className=\"page-not-found\">\n        <h1>404</h1>\n        <div className=\"page-not-found__message\">\n            Looks like you've lost your way\n        </div>\n        <Link to=\"/\" className=\"link-button page-not-found__btn\">\n            Go Home\n        </Link>\n    </div>\n}\n\nexport default PageNotFound;","module.exports = __webpack_public_path__ + \"static/media/piece.e03fada0.svg\";"],"sourceRoot":""}