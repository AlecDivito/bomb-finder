{"version":3,"sources":["models/GameTypes.ts","logic/BombFinder.ts","util/InSquare.ts","logic/InputController.ts","components/Gameheader.tsx","components/Switch.tsx","components/GameFooter.tsx","components/GameBoard.tsx","pages/game.tsx","components/Button.tsx","logic/Animation.ts","models/GameBoardTypes.ts","util/toHHMMSS.ts","logic/BombFinderPieceRenderer.ts","util/Random.ts","models/Preferences.ts","assets/hourglass.svg","pages/page-not-found.tsx","assets/piece.svg"],"names":["InputMode","GameStatus","BombFinder","games","settings","minWidth","minHeight","Object","classCallCheck","this","pieceRenderer","grid","updateRemainingPiecesCount","remainingPieces","inputMode","TOGGLE","backgroundAnimation","height","width","offsetWidth","offsetHeight","overflowClasses","BombFinderPieceRenderer","calculatedWidth","calculateBoardSize","calculatedHeight","AnimationTimer","setMarkInput","init","markFlag","arguments","length","undefined","MARK","setTarget","setStep","play","reset","newGame","id","Error","logAndDestroy","delta","isComplete","update","gameHasStarted","totalPieces","calcDelta","time","counter","forEach","cell","isVisible","visibility","isBomb","value","invisiblePieces","getRemainingAvailablePiece","totalMoves","result","state","CellState","BOMB","Visibility","VISIBLE","board","events","includes","keys","hover","index","getIndexByPixel","pos","leftClick","INVISIBLE","toggleCell","setCellVisibility","rightClick","isMarkable","MARKED","markCell","constructGrid","neighbors","getNeighbors","visited","i","pop","isMarked","newIndex","push","_this","neighbor","_this2","reduce","pre","VISIBLY_SATISFIED","point","cellSize","gridGapSize","defaultCellSize","row","Math","floor","y","col","x","top","left","square","size","InSquare","getIndex","area","bombCounter","bombs","defaultCell","random","bombProximityCounter","neighborIndex","CLEAN","j","tempRow","tempCol","tempIndex","ctx","canvasWindow","drawBackground","drawBoard","save","fillStyle","fillRect","restore","totalPieceSize","startingColOffset","max","startingRowOffset","startingRow","startingCol","endingCol","min","ceil","endingRow","drawPiece","InputController","listeners","timer","touchTimer","touchThreshold","touchPoint","idCounter","mouseEvent","event","type","buttons","middleClick","pageX","pageY","stopContextMenu","preventDefault","stopPropagation","touchEvent","Date","now","targetTouches","keydownEvent","key","element","uniqueId","listeningTo","pointer","getFunctionPointer","window","addEventListener","passive","rect","getBoundingClientRect","_this3","removeEventListener","eventType","GameHeader","props","react_default","a","createElement","className","src","piece","alt","pieces","react_router_dom","to","toHHMMSS","hourglass","Switch","checked","onChange","GameFooter","isChecked","isSwitchChecked","info","src_components_Switch","flagToggle","target","GameBoard","stopUpdates","rafId","lastFrame","container","canvas","context2D","gameState","input","ready","gameOver","canVibrate","canTryAgain","toMainMenu","changeInputMode","tryAgain","_callee","newGameId","regenerator_default","wrap","_context","prev","next","sent","setState","t0","console","warn","stop","goToMainMenu","_callee2","_context2","logAndDestory","draw","elapsedTime","pollEvents","inputId","handleEvents","forceUpdate","viewport","scrollLeft","scrollTop","clientWidth","clientHeight","isGameOver","flush","isGameWon","onGameFinished","navigator","vibrate","requestAnimationFrame","getTime","prevProps","prevState","destroyGame","createGame","Games","GetById","Preferences","GetPreferences","preferences","page","document","getElementById","getContext","start","gameBoardWidth","gameBoardHeight","innerWidth","vibration","cancelAnimationFrame","react_router","route","concat","Loading","dimensions","canvasBoardClass","gameBoardOverflowClasses","Gameheader","Button","text","onClick","components_GameFooter","isInputModeToggle","Component","Game","to404Page","toWonPage","redirecting","gameFinished","DoesGameExists","match","params","page_not_found","src_components_GameBoard","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","disabled","disabledClass","classes","LoopOptions","step","loop","STOP","_Users_alecdivito_Documents_JS_bomb_finder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","playing","alternated","REPEAT","ALTERNATE","d","__webpack_exports__","v","cv","hours","minutes","seconds","timeString","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","pieceLength","gapSize","simpleRender","exampleCellValue","setSpinningCubes","spinningCubes","drawInvisiblePiece","drawVisibleCell","num","pow","ipcContext","impcContext","clearRect","drawImage","drawHover","getIndexByCell","overrideColor","beginPath","strokeStyle","drawRectangle","lineWidth","stroke","closePath","s","jump","rotation","drawRotatingSquare","worldX","worldY","cellLength","rotationDirection","radius","totalLength","translate","rotate","getValue","PI","moveTo","lineTo","quadraticCurveTo","alpha","cellValue","arc","innerX","innerY","gradient","createRadialGradient","addColorStop","fill","font","offset","ypos","xpos","textAlign","textBaseline","fillText","String","Table","Field","tableName","Query","getById","cachedSettings","timestamp","assign","module","exports","p","r","react_router_dom__WEBPACK_IMPORTED_MODULE_3__","PageNotFound"],"mappings":"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","file":"static/js/4.f19024b1.chunk.js","sourcesContent":["export enum InputMode {\n    TOGGLE,\n    MARK,\n}\n\nexport interface Point2d {\n    x: number;\n    y: number;\n}\n\nexport enum GameStatus {\n    GAME_PAUSED,\n    GAME_PLAY,\n}\n\nexport type GameDifficulty = \"easy\" | \"medium\" | \"hard\" | string;\n\nexport type GameProgress = \"created\" | \"inprogress\" | \"lost\" | \"won\";\n\n","import { Cell, CellState, CellValue, Visibility, isVisible, isBomb, isMarkable, isMarked } from \"../models/GameBoardTypes\";\nimport { SimpleEventState } from \"../models/EventTypes\";\nimport InSquare from \"../util/InSquare\";\nimport { Point2d, InputMode } from \"../models/GameTypes\";\nimport Games from \"../models/Games\";\nimport { IPreferences } from \"../models/Preferences\";\nimport AnimationTimer from \"./Animation\";\nimport BombFinderPieceRenderer, { CanvasWindow } from \"./BombFinderPieceRenderer\";\n\nexport default class BombFinder {\n\n    // template data\n    private games: Games;\n    private settings: IPreferences;\n    private pieceRenderer: BombFinderPieceRenderer;\n\n    // game play\n    private grid: Cell[] = [];\n    private updateRemainingPiecesCount: boolean = false;\n    private remainingPieces: number = 0;\n    private inputMode: InputMode = InputMode.TOGGLE;\n\n    // animations\n    private readonly backgroundAnimation: AnimationTimer;\n\n    // canvas data\n    private readonly height: number;\n    private readonly width: number;\n    private readonly offsetWidth: number;\n    private readonly offsetHeight: number;\n    private readonly overflowClasses: string = \"\";\n\n    constructor(games: Games, settings: IPreferences, minWidth: number, minHeight: number) {\n        this.games = games;\n        this.settings = settings;\n        this.pieceRenderer = new BombFinderPieceRenderer(settings);\n\n        const calculatedWidth = this.calculateBoardSize(this.games.width);\n        const calculatedHeight = this.calculateBoardSize(this.games.height);\n\n        if (minWidth > calculatedWidth) {\n            this.width = minWidth;\n            this.offsetWidth = (this.width - calculatedWidth) / 2;;\n        } else {\n            this.overflowClasses += \" overflow-x\"; \n            this.width = calculatedWidth;\n            this.offsetWidth = 0;\n        }\n\n        if (minHeight > calculatedHeight) {\n            this.height = minHeight;\n            this.offsetHeight = (this.height - calculatedHeight) / 2;\n        } else {\n            this.overflowClasses += \" overflow-y\"; \n            this.height = calculatedHeight;\n            this.offsetHeight = 0;\n        }\n        this.backgroundAnimation = new AnimationTimer(121, 3);            \n        this.setMarkInput();\n\n        this.init();\n    }\n\n    public get isInputModeToggle() {\n        return InputMode.TOGGLE === this.inputMode;\n    }\n\n    public get gameBoardOverflowClasses() {\n        return this.overflowClasses;\n    }\n\n    public get gameBoardWidth() {\n        return this.width;\n    }\n\n    public get gameBoardHeight() {\n        return this.height;\n    }\n\n    public get gameState() {\n        return this.games.result;\n    }\n\n    public get isGameOver() {\n        return this.games.result === \"lost\" || this.games.result === \"won\";\n    }\n\n    public get isGameWon() {\n        return this.games.result === \"won\";\n    }\n\n    public get getRemainingAvailablePiece() {\n        return this.remainingPieces;\n    }\n\n    public get getTime() {\n        return Math.floor(this.games.time);\n    }\n\n    public setMarkInput(markFlag: boolean = false) {\n        this.inputMode = (markFlag) ? InputMode.MARK : InputMode.TOGGLE;\n        if (this.inputMode === InputMode.MARK) {\n            this.backgroundAnimation.setTarget(121);\n            this.backgroundAnimation.setStep(3);\n            this.backgroundAnimation.play();\n        } else if (this.inputMode === InputMode.TOGGLE) {\n            this.backgroundAnimation.setTarget(0);\n            this.backgroundAnimation.setStep(-3);\n            this.backgroundAnimation.play();\n        }\n    }\n\n    public async reset(): Promise<string> {\n        const newGame = await this.games.reset(this.games);\n        if (newGame) {\n            return newGame.id;\n        }\n        throw new Error(\"Had a problem saving old Game\");\n    }\n\n    public async logAndDestory() {\n        return await this.games.logAndDestroy();\n    }\n\n    public update(delta: number) {\n        if (this.games.isComplete) {\n            return;\n        }\n        this.pieceRenderer.update(delta);\n        this.backgroundAnimation.update(delta);\n        if (this.games.gameHasStarted && this.remainingPieces !== this.games.totalPieces) {\n            const calcDelta = delta / 1000;\n            this.games.time += calcDelta;\n        }\n        if (this.updateRemainingPiecesCount) {\n            let counter = this.games.totalPieces;\n            this.grid.forEach((cell) =>\n                (isVisible(cell.visibility) && !isBomb(cell.value))\n                    ? counter--\n                    : counter\n            );\n            this.remainingPieces = counter;\n            this.updateRemainingPiecesCount = false;\n            this.games.invisiblePieces = this.getRemainingAvailablePiece;\n            this.games.totalMoves++;\n            this.games.update();\n        }\n        if (!this.games.isComplete && (this.games.result === \"lost\" || this.remainingPieces === 0)) {\n            this.grid.forEach((cell) => {\n                if (cell.state === CellState.BOMB) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n            this.games.board = this.grid;\n            if (this.games.result === \"lost\") {\n                this.games.result = \"lost\";\n                this.games.update();\n            }\n            else if (this.remainingPieces === 0) {\n                this.games.result = \"won\";\n                this.games.update();\n            }\n            this.games.isComplete = true;\n        }\n    }\n\n    public handleEvents(events?: SimpleEventState) {\n        if (this.games.result !== \"inprogress\" && this.games.result !== \"created\") {\n            return;\n        }\n        if (!events) {\n            return;\n        }\n        if (events.events.includes(\"keydown\")) {\n            if (events.keys.includes(\"f\")) {\n                this.setMarkInput(this.inputMode === InputMode.TOGGLE);\n            }\n        }\n        if (events.events.includes(\"mousemove\")) {\n            this.grid.forEach((cell) => {\n                cell.hover = false;\n            });\n            const index = this.getIndexByPixel(events.pos);\n            if (index !== null && index < this.grid.length && this.grid[index]) {\n                this.grid[index].hover = true;\n            }\n        }\n        if (events.events.includes(\"mousedown\") || events.events.includes(\"touch\")) {\n            this.games.result = \"inprogress\";\n            const index = this.getIndexByPixel(events.pos);\n            if (index === null || index >= this.grid.length) {\n                return;\n            }\n            const cell = this.grid[index];\n            if (this.inputMode === InputMode.TOGGLE && events.leftClick && cell.visibility === Visibility.INVISIBLE) {\n                if (isBomb(cell.value)) {\n                    this.games.result = \"lost\";\n                }\n                if (cell.value === 0) {\n                    this.toggleCell(index);\n                }\n                this.setCellVisibility(index);\n            } else if (events.rightClick || (events.leftClick && this.inputMode === InputMode.MARK)) {\n                if (isMarkable(cell.visibility)) {\n                    cell.visibility = (cell.visibility === Visibility.MARKED)\n                        ? Visibility.INVISIBLE\n                        : Visibility.MARKED;\n                    this.markCell(index);\n                }\n            }\n            this.updateRemainingPiecesCount = true;\n        }\n        if (this.games.result === \"lost\") {\n            this.grid.forEach((cell) => {\n                if (isBomb(cell.value)) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n        }\n    }\n\n    protected init() {\n        this.remainingPieces = this.games.totalPieces;\n        if (this.games.board.length === 0) {\n            this.grid = this.constructGrid();\n            this.games.board = this.grid;\n        }\n        else {\n            this.grid = this.games.board;\n        }\n    }\n\n    private toggleCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        const visited: number[] = [index];\n        while (neighbors.length > 0) {\n            const i = neighbors.pop()!;\n            if (this.grid[i].value === 0 && !isMarked(this.grid[i])) {\n                const newNeighbors = this.getNeighbors(i);\n                newNeighbors.forEach((newIndex) => {\n                    if (!neighbors.includes(newIndex) && !visited.includes(newIndex)) {\n                        neighbors.push(newIndex);\n                    }\n                });\n            }\n            this.setCellVisibility(i);\n            visited.push(i);\n        }\n    }\n\n    private markCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        neighbors.forEach((neighbor) => {\n            const cell = this.grid[neighbor];\n            if (isVisible(cell.visibility) && !isBomb(cell.value) && cell.value !== 0) {\n                this.setCellVisibility(neighbor);\n            }\n        });\n    }\n\n    private setCellVisibility(index: number) {\n        if (isMarked(this.grid[index])) {\n            return;\n        }\n        if (this.grid[index].value === null || this.grid[index].value === 0) {\n            this.grid[index].visibility = Visibility.VISIBLE;\n            return;\n        }\n        const neighbor = this.getNeighbors(index);\n        const count = neighbor.reduce((pre, index) => {\n            const cell = this.grid[index];\n            if (cell.visibility === Visibility.MARKED) {\n                return pre + 1;\n            }\n            return pre;\n        }, 0);\n        if (count >= this.grid[index].value!) {\n            this.grid[index].visibility = Visibility.VISIBLY_SATISFIED\n        } else {\n            this.grid[index].visibility = Visibility.VISIBLE;\n        }\n    }\n\n    private getIndexByPixel(point: Point2d): number | null {\n        const cellSize = this.settings.gridGapSize + this.settings.defaultCellSize;\n        const row = Math.floor((point.y - this.offsetHeight) / cellSize);\n        const col = Math.floor((point.x - this.offsetWidth) / cellSize);\n\n        // check if pointer is inside square\n        const top =  this.offsetHeight + ((row * cellSize) + this.settings.gridGapSize);\n        const left = this.offsetWidth + ((col * cellSize) + this.settings.gridGapSize);\n\n        if (row >= 0 && col >= 0 && col < this.games.width && row < this.games.height &&\n            InSquare({top, left, size: this.settings.defaultCellSize }, point)) {\n            return this.getIndex(row, col);\n        }\n        return null;\n    }\n\n    private getIndex(row: number, col: number): number {\n        return (row * this.games.width) + col;\n    }\n\n    private constructGrid(): Cell[] {\n        const grid: Array<Cell | null> = [];\n\n        // create the grid\n        for (let i = 0; i < this.games.area; i++) {\n            grid.push(null);\n        }\n\n        // place the bombs\n        let bombCounter = this.games.bombs;\n        while (bombCounter > 0) {\n            const defaultCell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.BOMB,\n            }\n            const index = Math.floor(Math.random() * this.games.area);\n\n            if (grid[index] === null) {\n                bombCounter--;\n                grid[index] = defaultCell;\n            }\n        }\n\n        // place safe spaces\n        for (let index = 0; index < grid.length; index++) {\n            if (grid[index] !== null) { // if this is a bomb\n                continue;\n            }\n\n            let bombProximityCounter = 0;\n            const neighbors = this.getNeighbors(index);\n            for (let i = 0; i < neighbors.length; i++) {\n                const neighborIndex = neighbors[i];\n                if (grid[neighborIndex] !== null && grid[neighborIndex]!.state === CellState.BOMB) {\n                    bombProximityCounter++;\n                }\n            }\n            const cell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.CLEAN,\n                value: bombProximityCounter as CellValue,\n            };\n            grid[index] = cell;\n        }\n\n        return grid as Cell[];\n    }\n\n    private getNeighbors(index: number): number[] {\n        if (index < 0 || index >= this.games.area) {\n            return [];\n        }\n        const row = Math.floor(index / this.games.width);\n        const col = index % this.games.width;\n        const neighbors = [];\n        for (let j = 0; j < 8; j++) {\n            let tempRow = row;\n            let tempCol = col;\n            switch (j) {\n                case 0:\n                    tempRow -= 1;\n                    tempCol -= 1;\n                    break;\n                case 1: tempRow -= 1; break;\n                case 2:\n                    tempRow -= 1;\n                    tempCol += 1;\n                    break;\n                case 3: tempCol -= 1; break;\n                case 4: tempCol += 1; break;\n                case 5:\n                    tempRow += 1;\n                    tempCol -= 1;\n                    break;\n                case 6: tempRow += 1; break;\n                case 7:\n                    tempRow += 1;\n                    tempCol += 1;\n                    break;\n            }\n            const tempIndex = this.getIndex(tempRow, tempCol);\n            if (tempRow >= 0 && tempRow < this.games.height && // check if the index is in the gird\n                tempCol >= 0 && tempCol < this.games.width) {\n                neighbors.push(tempIndex);\n            }\n        }\n        \n        return neighbors;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        // TODO: futher optimizations \n        // TODO: Render screen differences only, not the whole new state.\n        this.drawBackground(ctx);\n        this.drawBoard(ctx, canvasWindow);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        // const gradient1 = ctx.createLinearGradient(this.width / 2,\n        //     this.height, this.width / 2, 0);\n        // gradient1.addColorStop(0.05, '#333');\n        // gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 50%, 1)`);\n        ctx.fillStyle = \"#333\"; //gradient1;\n        ctx.fillRect(0, 0, this.width, this.height);\n        ctx.restore();\n    }\n\n    private drawBoard(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        const totalPieceSize = this.settings.defaultCellSize + this.settings.gridGapSize;\n        const startingColOffset = Math.max(this.width, canvasWindow.width) - canvasWindow.width;\n        const startingRowOffset = Math.max(this.height, canvasWindow.height) - canvasWindow.height;\n\n        const startingRow = Math.floor(canvasWindow.x / (totalPieceSize + startingColOffset + 1));\n        const startingCol = Math.floor(canvasWindow.y / (totalPieceSize + startingRowOffset + 1));\n\n        const endingCol = Math.min(Math.ceil(\n            (canvasWindow.x + canvasWindow.width - this.offsetWidth) / totalPieceSize) + 1,\n            this.games.width);\n        const endingRow = Math.min(Math.ceil(\n            (canvasWindow.y + canvasWindow.height - this.offsetHeight) / totalPieceSize) + 1,\n            this.games.height);\n\n        for (let row = startingRow; row < endingRow; row++) {\n            for (let col = startingCol; col < endingCol; col++) {\n                // position\n                const x = this.offsetWidth + this.calculateBoardSize(col);\n                const y = this.offsetHeight + this.calculateBoardSize(row);\n                const index = this.getIndex(row, col);\n                const cell = this.grid[index];\n\n                /**\n                 * This is what I want to be able to call\n                 */\n                if (cell) {\n                    this.pieceRenderer.drawPiece(ctx, cell, x, y);\n                }\n            }    \n        }\n    }\n\n    private calculateBoardSize(size: number) {\n        return (size * this.settings.defaultCellSize) + ((size + 1) * this.settings.gridGapSize)\n    }\n}\n","import { Point2d } from \"../models/GameTypes\";\n\nexport default function InSquare(square: {\n    top: number,\n    left: number,\n    size: number,\n}, point: Point2d): boolean {\n    return point.y >= square.top && point.y <= square.top + square.size &&\n        point.x >= square.left && point.x <= square.left + square.size\n}","import { SimpleEventState } from \"../models/EventTypes\";\nimport { Point2d } from \"../models/GameTypes\";\n\ninterface Listener {\n    element: HTMLElement;\n    listeningTo: Array<keyof HTMLElementEventMap>;\n}\n\n// why not use\n// https://reactjs.org/docs/events.html#pointer-events\nexport default class InputController {\n\n    private listeners: { [key: number]: Listener } = {};\n    private timer: number = 0;\n    private touchTimer: number = 0;\n    private touchThreshold: number = 300;\n    private touchPoint?: Point2d;\n    private idCounter: number = 0;\n\n    private state?: SimpleEventState;\n\n    /**\n     * Place event listeners on a html element\n     * \n     * @param {HTMLElement} element element events to be placed on\n     * @param {String[]} events events to subscribe to\n     * @returns {number} id that tracks your current input session\n     */\n    public start(element: HTMLElement, events: Array<keyof HTMLElementEventMap>): number {\n        // add to listeners\n        const id = this.uniqueId();\n        this.listeners[id] = {\n            element,\n            listeningTo: []\n        };\n\n        events.forEach((event) => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.addEventListener(event, pointer as any);\n            }\n            else {\n                this.listeners[id].element.addEventListener(event, pointer as any, {\n                    passive: event !== \"contextmenu\",\n                });\n            }\n            this.listeners[id].listeningTo.push(event);\n        });\n\n        return id;\n    }\n\n    /**\n     * Get all event that happened\n     * \n     * Remember to call flush() or else you will get old events that persisted\n     * between frames\n     * \n     * @param {number} id - The events binded to the element you want\n     * @returns {Point2d | null} returns mouses new position or null if the \n     *      mouse hasn't moved since last checked\n     */\n    public pollEvents(id: number): SimpleEventState | undefined {\n        if (this.state) {\n            const rect = this.listeners[id].element.getBoundingClientRect();\n            this.state.pos.x -= rect.left;\n            this.state.pos.y -= rect.top;\n        }\n        return this.state;\n    }\n\n    /**\n     * Remove all of the input state from the controller\n     * @returns {void} \n     */\n    public flush() {\n        this.state = undefined;\n    }\n\n    public stop(id: number): boolean {\n        if (this.listeners[id] === undefined) {\n            return false;\n        }\n\n        this.listeners[id].listeningTo.forEach(event => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.removeEventListener(event, pointer as any);\n            } else {\n                this.listeners[id].element.removeEventListener(event, pointer as any);\n            }\n        });\n\n        return true;\n    }\n\n    private getFunctionPointer(eventType: keyof HTMLElementEventMap) {\n        switch (eventType) {\n            case \"mousemove\": return this.mouseEvent;\n            case \"mousedown\": return this.mouseEvent;\n            case \"mouseup\": return this.mouseEvent;\n            case \"contextmenu\": return this.stopContextMenu;\n            case \"touchstart\": return this.touchEvent;\n            case \"touchmove\": return this.touchEvent;\n            case \"touchend\": return this.touchEvent;\n            case \"keydown\": return this.keydownEvent;\n        }\n    }\n\n    private mouseEvent = (event: MouseEvent) => {\n        if (this.touchPoint) { // this means touch is active\n            return;\n        }\n        if (this.state && this.state.events.includes(\"touch\")) {\n            return;\n        }\n        if (this.state) {\n            this.state.events.push(event.type as any);\n            return;\n        }\n        this.state = {\n            leftClick: [1, 3, 5, 7].includes(event.buttons),\n            middleClick: [4, 5, 6, 7].includes(event.buttons),\n            rightClick: [2, 3, 6, 7].includes(event.buttons),\n            pos: {\n                x: event.pageX,\n                y: event.pageY,\n            },\n            keys: (this.state) ? this.state!.keys : [],\n            events: [event.type as any]\n        };\n    }\n\n    private stopContextMenu = (event: any) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    }\n\n    private touchEvent = (event: TouchEvent) => {\n        if (event.type === \"touchstart\") {\n            if (this.touchTimer === 0) {\n                this.timer = Date.now();\n            }\n            this.touchPoint = {\n                x: event.targetTouches[0].pageX,\n                y: event.targetTouches[0].pageY,\n            };\n            return;\n        }\n\n        if (event.type === \"touchmove\") {\n            this.touchPoint = undefined;\n            return;\n        }\n\n        if (event.type === \"touchend\" && this.touchPoint) {\n            const delta = Date.now() - this.timer;\n            this.timer = Date.now();\n            this.touchTimer += delta;\n            this.state = {\n                leftClick: this.touchTimer < this.touchThreshold,\n                middleClick: false,\n                rightClick: this.touchTimer > this.touchThreshold,\n                pos: this.touchPoint!,\n                keys: (this.state) ? this.state!.keys : [],\n                events: [\"touch\"]\n            }\n            this.touchPoint = undefined;\n            this.touchTimer = 0;\n        }\n    }\n\n    private keydownEvent = (event: KeyboardEvent) => {\n        if(this.state) {\n            this.state.events.push(event.type as any);\n        }\n        if (this.state) {\n            this.state.keys.push(event.key);\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1 },\n                keys: [event.key],\n                events: [event.type as any]\n            };\n        }\n    }\n\n    private uniqueId() {\n        return this.idCounter++;\n    }\n}\n","import React from 'react';\nimport toHHMMSS from '../util/toHHMMSS';\nimport piece from \"../assets/piece.svg\";\nimport hourglass from \"../assets/hourglass.svg\";\nimport \"./Header.css\"\nimport { Link } from 'react-router-dom';\n\ninterface Props {\n    time: number;\n    left: number;\n    pieces: number;\n}\n\nconst GameHeader: React.FC<Props> = (props: Props) => {\n    return <header className=\"header  header--game\">\n        <div className=\"header__detail\" >\n            <img src={piece} alt=\"Home\" />\n            <span>{props.left}/{props.pieces}</span>\n        </div>\n        <h3>\n            <Link to=\"/\">BombFinder</Link>\n        </h3>\n        <div className=\"header__detail\">\n            <span>{toHHMMSS(props.time)}</span>\n            <img src={hourglass} alt=\"Home\" />\n        </div>\n    </header>\n}\n\nexport default GameHeader;","import React from 'react';\nimport \"./Switch.css\";\n\ninterface Props {\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Switch: React.FC<Props> = (props: Props) => {\n    return <label className=\"switch\">\n        <input\n            checked={props.checked}\n            onChange={props.onChange}\n            className=\"switch__input\"\n            type=\"checkbox\" />\n        <span className=\"switch__box\">\n            <span className=\"switch__marker\" />\n        </span>\n    </label>\n}\n\nexport default Switch;","import React from 'react';\nimport info from \"../assets/info.svg\";\nimport settings from \"../assets/cog-f.svg\";\nimport { Link } from 'react-router-dom';\nimport \"./Footer.css\"\nimport Switch from './Switch';\n\ninterface Props {\n    isSwitchChecked?: boolean;\n    flagToggle: (value: boolean) => void;\n}\n\nconst GameFooter: React.FC<Props> = (props: Props) => {\n    const isChecked = (props.isSwitchChecked) ? true : false;\n    return (\n        <footer className=\"footer footer--game\">\n            <Link to=\"/how-to-play\">\n                <img src={info} alt=\"Info\" />\n            </Link>\n            <div className=\"footer__text\">\n                <span>Clear</span>\n                <Switch\n                    checked={isChecked}\n                    onChange={(event: any) => props.flagToggle(event.target.checked) }/>\n                <span>Flag</span>\n            </div>\n            <Link to=\"/settings\">\n                <img src={settings} alt=\"Settings\" />\n            </Link>\n        </footer>\n    );\n}\n\nexport default GameFooter;","import React, { Component } from 'react';\nimport BombFinder from \"../logic/BombFinder\";\nimport InputController from \"../logic/InputController\";\nimport { Redirect } from 'react-router-dom';\nimport { GameProgress } from '../models/GameTypes';\nimport { CanvasWindow } from '../logic/BombFinderPieceRenderer';\nimport Games from '../models/Games';\nimport Loading from './Loading';\nimport Preferences from '../models/Preferences';\nimport Button from './Button';\nimport GameHeader from './Gameheader';\nimport GameFooter from './GameFooter';\nimport './GameBoard.css';\n\ninterface Props {\n    id: string;\n    onGameFinished: (result: GameProgress) => void\n}\n\ninterface State {\n    ready: boolean;\n    gameOver: boolean;\n    canVibrate: boolean;\n    canTryAgain: boolean;\n    toMainMenu: boolean;\n    totalPieces: number;\n    newGameId?: string;\n    inputId?: number;\n    time: number;\n}\n\nclass GameBoard extends Component<Props, State> {\n\n    private stopUpdates: boolean = false;\n    private rafId?: number;\n    private lastFrame: number = 0;\n\n    private container?: HTMLDivElement;\n    private canvas?: HTMLCanvasElement;\n    // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#Turn_off_transparency\n    private context2D?: CanvasRenderingContext2D;\n    private gameState?: BombFinder;\n    private input?: InputController;\n\n    state: Readonly<State> = {\n        ready: false,\n        gameOver: false,\n        canVibrate: false,\n        canTryAgain: false,\n        toMainMenu: false,\n        totalPieces: 0,\n        time: 0,\n    }\n\n    public componentDidUpdate(prevProps: Props, prevState: State) {\n        if (prevState.newGameId && prevProps.id !== prevState.newGameId) {\n            // new game has started without unmounting the component\n            this.setState({\n                ready: false,\n                gameOver: false,\n                canTryAgain: false,\n                time: 0,\n                newGameId: undefined,\n                inputId: undefined,\n            });\n            this.destroyGame();\n            this.createGame();\n        }\n    }\n\n    public async componentDidMount() {\n        this.createGame();\n    }\n\n    public componentWillUnmount() {\n        this.stopUpdates = true;\n        this.destroyGame();\n    }\n\n    public async createGame() {\n        // TODO: GetById error handling\n        const games = await Games.GetById(this.props.id)!;\n        const preferences = await Preferences.GetPreferences();\n        const page = document.getElementById(\"page\") as HTMLDivElement;\n        if (games.result === \"won\") {\n            this.props.onGameFinished(games.result);\n            return;\n        }\n        // TODO: Remove magic number\n        this.gameState = new BombFinder(games, preferences, page.clientWidth, page.clientHeight - 120);\n        this.input = new InputController();\n        this.setState({ ready: true, totalPieces: games.totalPieces });\n        this.canvas = document.getElementById(\"board\") as HTMLCanvasElement;\n        this.container = document.getElementById(\"board-container\") as HTMLDivElement;\n        this.context2D = this.canvas.getContext(\"2d\")!;\n\n        const inputId = this.input.start(this.canvas!, [\"mousemove\", \"mousedown\",\n            \"contextmenu\", \"touchstart\", \"touchmove\", \"touchend\", \"keydown\"]);\n\n        // TODO: Add error handling\n        this.canvas!.width = this.gameState!.gameBoardWidth;\n        this.canvas!.height = this.gameState!.gameBoardHeight;\n        this.container.scrollLeft = (this.gameState!.gameBoardWidth - window.innerWidth) / 2;\n        this.setState({ ready: true, inputId: inputId, canVibrate: preferences.vibration });\n        requestAnimationFrame(this.draw);\n    }\n\n    public destroyGame() {\n        if (this.state.ready && this.state.inputId) {\n            this.input!.stop(this.state.inputId!);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId!);\n        }\n    }\n\n    public changeInputMode = (markFlag: boolean) => {\n        this.gameState!.setMarkInput(markFlag);\n        // this.gameState!.draw(this.context2D!);\n    }\n\n    public tryAgain = async () => {\n        if (this.state.ready && !this.state.newGameId && this.state.canTryAgain) {\n            try {\n                const newGameId = await this.gameState!.reset();\n                this.setState({ ready: false, newGameId });\n            } catch (e) {\n                console.warn(\"error \" + e);\n                // TODO: implement Error handling\n            }\n        }\n    }\n\n    public goToMainMenu = async () => {\n        if (this.state.ready) {\n            const logged = await this.gameState!.logAndDestory();\n            if (logged) {\n                this.setState({toMainMenu: true});\n            }\n        }\n    }\n\n    public render() {\n        if (this.state.toMainMenu) {\n            return <Redirect to=\"/\" />;\n        }\n        if (this.state.newGameId) {\n            const route = `/game/${this.state.newGameId}`;\n            return <Redirect to={route} />;\n        }\n        if (!this.state.ready) {\n            return <Loading />\n        }\n        const dimensions = {\n            height: this.gameState!.gameBoardHeight,\n            width: this.gameState!.gameBoardWidth,\n        };\n        let canvasBoardClass = \"board__canvas \" + this.gameState!.gameBoardOverflowClasses;\n        return (\n            <div className=\"board\">\n                <GameHeader time={this.gameState!.getTime}\n                    left={this.gameState!.getRemainingAvailablePiece}\n                    pieces={this.state.totalPieces}/>\n                <div className={canvasBoardClass} id=\"board-container\">\n                    <canvas id=\"board\"\n                        className={this.gameState!.gameState}\n                        width={dimensions.width}\n                        height={dimensions.height} />\n                    {(this.state.gameOver)\n                        ? <div className=\"board__popup\">\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Try Again\"\n                                onClick={this.tryAgain} />\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Main Menu\"\n                                onClick={this.goToMainMenu} />\n                        </div>\n                        : null\n                    }\n                </div>\n                <GameFooter\n                    isSwitchChecked={!this.gameState!.isInputModeToggle}\n                    flagToggle={this.changeInputMode} />\n            </div>\n        );\n    }\n\n    private draw = (delta: number) => {\n        if (!this.state.ready) {\n            // TODO: do we need this ready check for the game?????\n            return;\n        }\n        const elapsedTime = delta - this.lastFrame;\n        const events = this.input!.pollEvents(this.state.inputId!);\n        \n        if (events) {\n            this.gameState!.handleEvents(events);\n            if (events.keys.length > 0) {\n                this.forceUpdate();\n            }\n        }\n        this.gameState!.update(elapsedTime);\n        // TODO: calcuate playing area and send it to draw\n        const viewport: CanvasWindow = {\n            x: this.container!.scrollLeft, y: this.container!.scrollTop,\n            width: this.container!.clientWidth, height: this.container!.clientHeight\n        };\n        this.gameState!.draw(this.context2D!, viewport);\n        \n        // Initial draw call before any events\n        if (this.rafId === undefined || this.gameState!.isGameOver) {\n            this.gameState!.draw(this.context2D!, viewport);\n        }\n        \n        this.input!.flush();\n        \n        \n        if (this.gameState!.isGameOver) {\n            this.lastFrame = delta;\n            if (this.gameState!.isGameWon) {\n                this.props.onGameFinished(\"won\");\n            } else {\n                if (this.state.canVibrate && navigator.vibrate) {\n                    navigator.vibrate(200);\n                }\n                this.setState({\n                    gameOver: true,\n                    canVibrate: false,\n                    canTryAgain: true,\n                });\n            }\n        }\n\n        if (!this.stopUpdates) {\n            this.rafId = requestAnimationFrame(this.draw);\n            this.lastFrame = delta;\n            if (this.state.time !== this.gameState!.getTime) {\n                this.setState({ time: this.gameState!.getTime });\n            }\n        }\n    }\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport { GameProgress } from '../models/GameTypes';\nimport GameBoard from '../components/GameBoard';\nimport { RouteComponentProps, Redirect } from 'react-router';\nimport Games from '../models/Games';\nimport PageNotFound from './page-not-found';\n\ninterface ParamProps {\n    id: string;\n}\n\ntype Props = RouteComponentProps<ParamProps>;\n\ninterface State {\n    // for when the game is done\n    to404Page: boolean;\n    toWonPage: boolean;\n    redirecting: boolean;\n    ready: boolean;\n}\n\nexport default class Game extends Component<Props, State> {\n\n    state: Readonly<State> = {\n        to404Page: false,\n        toWonPage: false,\n        redirecting: false,\n        ready: false,\n    }\n\n    async componentDidMount() {\n        const exists = await Games.DoesGameExists(this.props.match.params.id);\n        if (exists) {\n            this.setState({ to404Page: false, ready: true });\n        }\n        else {\n            this.setState({ to404Page: true, ready: true });\n        }\n    }\n\n    gameFinished = (result: GameProgress) => {\n        this.setState({ toWonPage: result === \"won\" });\n    }\n\n    public render() {\n        if (this.state.toWonPage) {\n            return <Redirect to={`/game/${this.props.match.params.id}/game-won`} />\n        }\n        else if (this.state.to404Page) {\n            return <PageNotFound />;\n        }\n        else if (this.state.ready) {\n            return <GameBoard\n                id={this.props.match.params.id}\n                onGameFinished={this.gameFinished} />\n        } else {\n            return null;\n        }\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","\nexport enum LoopOptions {\n    REPEAT,\n    ALTERNATE,\n    STOP\n}\n\nexport default class AnimationTimer {\n\n    private playing: boolean;\n    private timer = 0;\n    private target: number;\n    private step: number;\n    private loop: LoopOptions;\n    private alternated: boolean;\n\n    constructor(target: number, step: number, loop: LoopOptions = LoopOptions.STOP) {\n        this.timer = 0;\n        this.target = target;\n        this.step = step;\n        this.loop = loop;\n        this.alternated = false;\n        this.playing = true;\n    }\n\n    update(delta: number) {\n        if (!this.isComplete() && this.playing) {\n            this.timer += this.step;\n        } else {\n            if (this.loop === LoopOptions.REPEAT) {\n                this.timer = this.timer % this.target;\n            } else if (this.loop === LoopOptions.ALTERNATE) {\n                this.setStep(this.step * -1);\n                if (!this.alternated) {\n                    this.timer = 0;\n                } else {\n                    this.timer = this.target;\n                }\n            } else if (this.loop === LoopOptions.STOP) {\n                this.timer = this.target;\n                this.stop();\n            }\n        }\n    }\n\n    public stop() {\n        this.playing = false;\n    }\n\n    public play() {\n        this.playing = true;\n    }\n\n    public getValue() {\n        return this.timer;\n    }\n\n    public setTarget(target: number) {\n        this.target = target;\n    }\n\n    public setStep(step: number) {\n        if (step < 0) {\n            this.alternated = true;\n        } else {\n            this.alternated = false;\n        }\n        this.step = step;\n    }\n\n    public isComplete() {\n        return (this.alternated)\n            ? this.timer <= 0\n            : this.timer >= this.target;\n    }\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","export default function toHHMMSS(time: number) {\n    time = Math.floor(time);\n    const hours = Math.floor(time / 3600);\n    const minutes = Math.floor((time - (hours * 3600)) / 60);\n    const seconds = time - (hours * 3600) - (minutes * 60);\n    let timeString = \"\";\n\n    if (hours > 0) {\n        timeString += (hours < 10) ? `0${hours}` : `${hours}`;\n    }\n    timeString += (minutes < 10) ? `0${minutes}:` : `${minutes}:`;\n    timeString += (seconds < 10) ? `0${seconds}` : `${seconds}`;\n\n    return timeString;\n}","import AnimationTimer, { LoopOptions } from \"./Animation\";\nimport { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    private pieceAnimations: AnimationTimer[] = [];\n\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.pieceLength = settings.defaultCellSize;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = this.pieceLength + 2;\n        this.invisiblePieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, 1, 1);\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = this.pieceLength + 2;\n        this.invisibleMarkedPieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, 1, 1, \"#3396ff\");\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = this.pieceLength + 2;\n            this.staticPieceCanvas[i].height = this.pieceLength + 2;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 1, 1.5, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 1, 1.5, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 1, 1.5, 0);\n            } else {\n                this.drawVisibleCell(ctx, 1, 1.5, undefined);\n            }\n        }\n    }\n\n    setCellSize(value: number) {\n        this.pieceLength = value;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(\n                new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    update(delta: number) {\n        if (this.simpleRender) {\n            return;\n        }\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            this.pieceAnimations[i].update(delta);\n        }\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        ipcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        impcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, 1, 1);\n        this.drawInvisiblePiece(impcContext, 1, 1, \"#3396ff\");\n    }\n\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, \"#3396ff\"); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, \"#3396ff\"); break;\n        }\n        ctx.restore();\n    }\n\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                this.drawHover(ctx, x + 1, y + 1);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n\n        if (this.simpleRender) {\n            return;\n        }\n\n        ctx.save();\n        let s = this.pieceLength;\n        let jump = 0;\n        for (let i = 1; i < this.pieceAnimations.length; i++) {\n            const rotation = (i % 2 === 0) ? 1 : -1;\n            this.drawRotatingSquare(ctx, jump + x, jump + y, s, i, rotation, overrideColor);\n            jump += (s / 4) / 2;\n            s = (s / 4) * 3;\n        }\n        ctx.restore();\n    }\n\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotationDirection: 1 | -1, overrideColor?: string) {\n        const radius = cellLength / 8;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - (radius);\n        let y = worldY + cellLength / 4 - (radius);\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + totalLength / 2, y + totalLength / 2);\n        ctx.rotate(this.pieceAnimations[i].getValue() *  Math.PI / 180);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawRectangle(ctx, x, y, radius, totalLength);\n        ctx.lineWidth = 2;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"gray\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    private drawRectangle(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        let alpha = 1.0;\n        for (let i = 1; i <= (this.gapSize / 2); i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawRectangle(ctx, x - i, y - i, (this.pieceLength) / 8,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= 0.1;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + 2;\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = 2;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}","module.exports = __webpack_public_path__ + \"static/media/hourglass.63a5448b.svg\";","import React from 'react';\nimport \"../components/Button.css\"\nimport \"./page-not-found.css\"\nimport { Link } from 'react-router-dom';\n\nconst PageNotFound: React.FC = () => {\n    return <div className=\"page-not-found\">\n        <h1>404</h1>\n        <div className=\"page-not-found__message\">\n            Looks like you've lost your way\n        </div>\n        <Link to=\"/\" className=\"link-button page-not-found__btn\">\n            Go Home\n        </Link>\n    </div>\n}\n\nexport default PageNotFound;","module.exports = __webpack_public_path__ + \"static/media/piece.e03fada0.svg\";"],"sourceRoot":""}