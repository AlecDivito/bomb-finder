{"version":3,"sources":["models/GameTypes.ts","logic/BombFinder.ts","util/InSquare.ts","logic/InputController.ts","components/Gameheader.tsx","components/Switch.tsx","components/GameFooter.tsx","components/GameBoard.tsx","pages/game.tsx","components/Button.tsx","logic/Animation.ts","models/GameBoardTypes.ts","util/toHHMMSS.ts","logic/BombFinderPieceRenderer.ts","util/Random.ts","models/Preferences.ts","assets/hourglass.svg","pages/page-not-found.tsx","assets/piece.svg"],"names":["InputMode","GameStatus","BombFinder","games","settings","minWidth","minHeight","Object","classCallCheck","this","pieceRenderer","grid","updateRemainingPiecesCount","remainingPieces","inputMode","TOGGLE","backgroundAnimation","height","width","offsetWidth","offsetHeight","overflowClasses","BombFinderPieceRenderer","calculatedWidth","calculateBoardSize","calculatedHeight","AnimationTimer","setMarkInput","init","markFlag","arguments","length","undefined","MARK","setTarget","setStep","play","reset","newGame","id","Error","logAndDestroy","delta","isComplete","update","gameHasStarted","totalPieces","calcDelta","time","counter","forEach","cell","isVisible","visibility","isBomb","value","invisiblePieces","getRemainingAvailablePiece","totalMoves","result","state","CellState","BOMB","Visibility","VISIBLE","board","events","includes","keys","hover","index","getIndexByPixel","pos","leftClick","INVISIBLE","toggleCell","setCellVisibility","rightClick","isMarkable","MARKED","markCell","constructGrid","neighbors","getNeighbors","visited","i","pop","isMarked","newIndex","push","_this","neighbor","_this2","reduce","pre","VISIBLY_SATISFIED","point","cellSize","gridGapSize","defaultCellSize","row","Math","floor","y","col","x","top","left","square","size","InSquare","getIndex","area","bombCounter","bombs","defaultCell","random","bombProximityCounter","neighborIndex","CLEAN","j","tempRow","tempCol","tempIndex","ctx","canvasWindow","drawBackground","drawBoard","save","gradient1","createLinearGradient","addColorStop","concat","getValue","fillStyle","fillRect","restore","totalPieceSize","startingColOffset","max","startingRowOffset","startingRow","startingCol","endingCol","min","ceil","endingRow","drawPiece","InputController","listeners","timer","touchTimer","touchThreshold","touchPoint","idCounter","mouseEvent","event","type","buttons","middleClick","pageX","pageY","stopContextMenu","preventDefault","stopPropagation","touchEvent","Date","now","targetTouches","keydownEvent","key","element","uniqueId","listeningTo","pointer","getFunctionPointer","window","addEventListener","passive","rect","getBoundingClientRect","_this3","removeEventListener","eventType","GameHeader","props","react_default","a","createElement","className","src","piece","alt","pieces","react_router_dom","to","toHHMMSS","hourglass","Switch","checked","onChange","GameFooter","isChecked","isSwitchChecked","info","src_components_Switch","flagToggle","target","GameBoard","stopUpdates","rafId","lastFrame","container","canvas","context2D","gameState","input","ready","gameOver","canVibrate","canTryAgain","toMainMenu","changeInputMode","tryAgain","_callee","newGameId","regenerator_default","wrap","_context","prev","next","sent","setState","t0","console","warn","stop","goToMainMenu","_callee2","_context2","logAndDestory","draw","elapsedTime","pollEvents","inputId","handleEvents","forceUpdate","viewport","scrollLeft","scrollTop","clientWidth","clientHeight","isGameOver","flush","isGameWon","onGameFinished","navigator","vibrate","requestAnimationFrame","getTime","prevProps","prevState","destroyGame","createGame","Games","GetById","Preferences","GetPreferences","preferences","page","document","getElementById","getContext","start","gameBoardWidth","gameBoardHeight","innerWidth","vibration","cancelAnimationFrame","react_router","route","Loading","dimensions","canvasBoardClass","gameBoardOverflowClasses","Gameheader","Button","text","onClick","components_GameFooter","isInputModeToggle","Component","Game","to404Page","toWonPage","redirecting","gameFinished","DoesGameExists","match","params","page_not_found","src_components_GameBoard","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","disabled","disabledClass","classes","LoopOptions","step","loop","STOP","_Users_alecdivito_Documents_JS_bomb_finder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","playing","alternated","REPEAT","ALTERNATE","d","__webpack_exports__","v","cv","hours","minutes","seconds","timeString","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","pieceLength","gapSize","simpleRender","exampleCellValue","setSpinningCubes","spinningCubes","drawInvisiblePiece","drawVisibleCell","num","pow","ipcContext","impcContext","clearRect","drawImage","drawHover","getIndexByCell","overrideColor","beginPath","strokeStyle","drawRectangle","lineWidth","stroke","closePath","s","jump","rotation","drawRotatingSquare","worldX","worldY","cellLength","rotationDirection","radius","totalLength","translate","rotate","PI","moveTo","lineTo","quadraticCurveTo","alpha","cellValue","arc","innerX","innerY","gradient","createRadialGradient","fill","font","offset","ypos","xpos","textAlign","textBaseline","fillText","String","Table","Field","tableName","Query","getById","cachedSettings","timestamp","assign","module","exports","p","r","react_router_dom__WEBPACK_IMPORTED_MODULE_3__","PageNotFound"],"mappings":"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","file":"static/js/4.5fda4300.chunk.js","sourcesContent":["export enum InputMode {\n    TOGGLE,\n    MARK,\n}\n\nexport interface Point2d {\n    x: number;\n    y: number;\n}\n\nexport enum GameStatus {\n    GAME_PAUSED,\n    GAME_PLAY,\n}\n\nexport type GameDifficulty = \"easy\" | \"medium\" | \"hard\" | string;\n\nexport type GameProgress = \"created\" | \"inprogress\" | \"lost\" | \"won\";\n\n","import { Cell, CellState, CellValue, Visibility, isVisible, isBomb, isMarkable, isMarked } from \"../models/GameBoardTypes\";\nimport { SimpleEventState } from \"../models/EventTypes\";\nimport InSquare from \"../util/InSquare\";\nimport { Point2d, InputMode } from \"../models/GameTypes\";\nimport Games from \"../models/Games\";\nimport { IPreferences } from \"../models/Preferences\";\nimport AnimationTimer from \"./Animation\";\nimport BombFinderPieceRenderer, { CanvasWindow } from \"./BombFinderPieceRenderer\";\n\nexport default class BombFinder {\n\n    // template data\n    private games: Games;\n    private settings: IPreferences;\n    private pieceRenderer: BombFinderPieceRenderer;\n\n    // game play\n    private grid: Cell[] = [];\n    private updateRemainingPiecesCount: boolean = false;\n    private remainingPieces: number = 0;\n    private inputMode: InputMode = InputMode.TOGGLE;\n\n    // animations\n    private readonly backgroundAnimation: AnimationTimer;\n\n    // canvas data\n    private readonly height: number;\n    private readonly width: number;\n    private readonly offsetWidth: number;\n    private readonly offsetHeight: number;\n    private readonly overflowClasses: string = \"\";\n\n    constructor(games: Games, settings: IPreferences, minWidth: number, minHeight: number) {\n        this.games = games;\n        this.settings = settings;\n        this.pieceRenderer = new BombFinderPieceRenderer(settings);\n\n        const calculatedWidth = this.calculateBoardSize(this.games.width);\n        const calculatedHeight = this.calculateBoardSize(this.games.height);\n\n        if (minWidth > calculatedWidth) {\n            this.width = minWidth;\n            this.offsetWidth = (this.width - calculatedWidth) / 2;;\n        } else {\n            this.overflowClasses += \" overflow-x\"; \n            this.width = calculatedWidth;\n            this.offsetWidth = 0;\n        }\n\n        if (minHeight > calculatedHeight) {\n            this.height = minHeight;\n            this.offsetHeight = (this.height - calculatedHeight) / 2;\n        } else {\n            this.overflowClasses += \" overflow-y\"; \n            this.height = calculatedHeight;\n            this.offsetHeight = 0;\n        }\n        this.backgroundAnimation = new AnimationTimer(121, 3);            \n        this.setMarkInput();\n\n        this.init();\n    }\n\n    public get isInputModeToggle() {\n        return InputMode.TOGGLE === this.inputMode;\n    }\n\n    public get gameBoardOverflowClasses() {\n        return this.overflowClasses;\n    }\n\n    public get gameBoardWidth() {\n        return this.width;\n    }\n\n    public get gameBoardHeight() {\n        return this.height;\n    }\n\n    public get gameState() {\n        return this.games.result;\n    }\n\n    public get isGameOver() {\n        return this.games.result === \"lost\" || this.games.result === \"won\";\n    }\n\n    public get isGameWon() {\n        return this.games.result === \"won\";\n    }\n\n    public get getRemainingAvailablePiece() {\n        return this.remainingPieces;\n    }\n\n    public get getTime() {\n        return Math.floor(this.games.time);\n    }\n\n    public setMarkInput(markFlag: boolean = false) {\n        this.inputMode = (markFlag) ? InputMode.MARK : InputMode.TOGGLE;\n        if (this.inputMode === InputMode.MARK) {\n            this.backgroundAnimation.setTarget(121);\n            this.backgroundAnimation.setStep(3);\n            this.backgroundAnimation.play();\n        } else if (this.inputMode === InputMode.TOGGLE) {\n            this.backgroundAnimation.setTarget(0);\n            this.backgroundAnimation.setStep(-3);\n            this.backgroundAnimation.play();\n        }\n    }\n\n    public async reset(): Promise<string> {\n        const newGame = await this.games.reset(this.games);\n        if (newGame) {\n            return newGame.id;\n        }\n        throw new Error(\"Had a problem saving old Game\");\n    }\n\n    public async logAndDestory() {\n        return await this.games.logAndDestroy();\n    }\n\n    public update(delta: number) {\n        if (this.games.isComplete) {\n            return;\n        }\n        this.pieceRenderer.update(delta);\n        this.backgroundAnimation.update(delta);\n        if (this.games.gameHasStarted && this.remainingPieces !== this.games.totalPieces) {\n            const calcDelta = delta / 1000;\n            this.games.time += calcDelta;\n        }\n        if (this.updateRemainingPiecesCount) {\n            let counter = this.games.totalPieces;\n            this.grid.forEach((cell) =>\n                (isVisible(cell.visibility) && !isBomb(cell.value))\n                    ? counter--\n                    : counter\n            );\n            this.remainingPieces = counter;\n            this.updateRemainingPiecesCount = false;\n            this.games.invisiblePieces = this.getRemainingAvailablePiece;\n            this.games.totalMoves++;\n            this.games.update();\n        }\n        if (!this.games.isComplete && (this.games.result === \"lost\" || this.remainingPieces === 0)) {\n            this.grid.forEach((cell) => {\n                if (cell.state === CellState.BOMB) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n            this.games.board = this.grid;\n            if (this.games.result === \"lost\") {\n                this.games.result = \"lost\";\n                this.games.update();\n            }\n            else if (this.remainingPieces === 0) {\n                this.games.result = \"won\";\n                this.games.update();\n            }\n            this.games.isComplete = true;\n        }\n    }\n\n    public handleEvents(events?: SimpleEventState) {\n        if (this.games.result !== \"inprogress\" && this.games.result !== \"created\") {\n            return;\n        }\n        if (!events) {\n            return;\n        }\n        if (events.events.includes(\"keydown\")) {\n            if (events.keys.includes(\"f\")) {\n                this.setMarkInput(this.inputMode === InputMode.TOGGLE);\n            }\n        }\n        if (events.events.includes(\"mousemove\")) {\n            this.grid.forEach((cell) => {\n                cell.hover = false;\n            });\n            const index = this.getIndexByPixel(events.pos);\n            if (index !== null && index < this.grid.length && this.grid[index]) {\n                this.grid[index].hover = true;\n            }\n        }\n        if (events.events.includes(\"mousedown\") || events.events.includes(\"touch\")) {\n            this.games.result = \"inprogress\";\n            const index = this.getIndexByPixel(events.pos);\n            if (index === null || index >= this.grid.length) {\n                return;\n            }\n            const cell = this.grid[index];\n            if (this.inputMode === InputMode.TOGGLE && events.leftClick && cell.visibility === Visibility.INVISIBLE) {\n                if (isBomb(cell.value)) {\n                    this.games.result = \"lost\";\n                }\n                if (cell.value === 0) {\n                    this.toggleCell(index);\n                }\n                this.setCellVisibility(index);\n            } else if (events.rightClick || (events.leftClick && this.inputMode === InputMode.MARK)) {\n                if (isMarkable(cell.visibility)) {\n                    cell.visibility = (cell.visibility === Visibility.MARKED)\n                        ? Visibility.INVISIBLE\n                        : Visibility.MARKED;\n                    this.markCell(index);\n                }\n            }\n            this.updateRemainingPiecesCount = true;\n        }\n        if (this.games.result === \"lost\") {\n            this.grid.forEach((cell) => {\n                if (isBomb(cell.value)) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n        }\n    }\n\n    protected init() {\n        this.remainingPieces = this.games.totalPieces;\n        if (this.games.board.length === 0) {\n            this.grid = this.constructGrid();\n            this.games.board = this.grid;\n        }\n        else {\n            this.grid = this.games.board;\n        }\n    }\n\n    private toggleCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        const visited: number[] = [index];\n        while (neighbors.length > 0) {\n            const i = neighbors.pop()!;\n            if (this.grid[i].value === 0 && !isMarked(this.grid[i])) {\n                const newNeighbors = this.getNeighbors(i);\n                newNeighbors.forEach((newIndex) => {\n                    if (!neighbors.includes(newIndex) && !visited.includes(newIndex)) {\n                        neighbors.push(newIndex);\n                    }\n                });\n            }\n            this.setCellVisibility(i);\n            visited.push(i);\n        }\n    }\n\n    private markCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        neighbors.forEach((neighbor) => {\n            const cell = this.grid[neighbor];\n            if (isVisible(cell.visibility) && !isBomb(cell.value) && cell.value !== 0) {\n                this.setCellVisibility(neighbor);\n            }\n        });\n    }\n\n    private setCellVisibility(index: number) {\n        if (isMarked(this.grid[index])) {\n            return;\n        }\n        if (this.grid[index].value === null || this.grid[index].value === 0) {\n            this.grid[index].visibility = Visibility.VISIBLE;\n            return;\n        }\n        const neighbor = this.getNeighbors(index);\n        const count = neighbor.reduce((pre, index) => {\n            const cell = this.grid[index];\n            if (cell.visibility === Visibility.MARKED) {\n                return pre + 1;\n            }\n            return pre;\n        }, 0);\n        if (count >= this.grid[index].value!) {\n            this.grid[index].visibility = Visibility.VISIBLY_SATISFIED\n        } else {\n            this.grid[index].visibility = Visibility.VISIBLE;\n        }\n    }\n\n    private getIndexByPixel(point: Point2d): number | null {\n        const cellSize = this.settings.gridGapSize + this.settings.defaultCellSize;\n        const row = Math.floor((point.y - this.offsetHeight) / cellSize);\n        const col = Math.floor((point.x - this.offsetWidth) / cellSize);\n\n        // check if pointer is inside square\n        const top =  this.offsetHeight + ((row * cellSize) + this.settings.gridGapSize);\n        const left = this.offsetWidth + ((col * cellSize) + this.settings.gridGapSize);\n\n        if (row >= 0 && col >= 0 && col < this.games.width && row < this.games.height &&\n            InSquare({top, left, size: this.settings.defaultCellSize }, point)) {\n            return this.getIndex(row, col);\n        }\n        return null;\n    }\n\n    private getIndex(row: number, col: number): number {\n        return (row * this.games.width) + col;\n    }\n\n    private constructGrid(): Cell[] {\n        const grid: Array<Cell | null> = [];\n\n        // create the grid\n        for (let i = 0; i < this.games.area; i++) {\n            grid.push(null);\n        }\n\n        // place the bombs\n        let bombCounter = this.games.bombs;\n        while (bombCounter > 0) {\n            const defaultCell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.BOMB,\n            }\n            const index = Math.floor(Math.random() * this.games.area);\n\n            if (grid[index] === null) {\n                bombCounter--;\n                grid[index] = defaultCell;\n            }\n        }\n\n        // place safe spaces\n        for (let index = 0; index < grid.length; index++) {\n            if (grid[index] !== null) { // if this is a bomb\n                continue;\n            }\n\n            let bombProximityCounter = 0;\n            const neighbors = this.getNeighbors(index);\n            for (let i = 0; i < neighbors.length; i++) {\n                const neighborIndex = neighbors[i];\n                if (grid[neighborIndex] !== null && grid[neighborIndex]!.state === CellState.BOMB) {\n                    bombProximityCounter++;\n                }\n            }\n            const cell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.CLEAN,\n                value: bombProximityCounter as CellValue,\n            };\n            grid[index] = cell;\n        }\n\n        return grid as Cell[];\n    }\n\n    private getNeighbors(index: number): number[] {\n        if (index < 0 || index >= this.games.area) {\n            return [];\n        }\n        const row = Math.floor(index / this.games.width);\n        const col = index % this.games.width;\n        const neighbors = [];\n        for (let j = 0; j < 8; j++) {\n            let tempRow = row;\n            let tempCol = col;\n            switch (j) {\n                case 0:\n                    tempRow -= 1;\n                    tempCol -= 1;\n                    break;\n                case 1: tempRow -= 1; break;\n                case 2:\n                    tempRow -= 1;\n                    tempCol += 1;\n                    break;\n                case 3: tempCol -= 1; break;\n                case 4: tempCol += 1; break;\n                case 5:\n                    tempRow += 1;\n                    tempCol -= 1;\n                    break;\n                case 6: tempRow += 1; break;\n                case 7:\n                    tempRow += 1;\n                    tempCol += 1;\n                    break;\n            }\n            const tempIndex = this.getIndex(tempRow, tempCol);\n            if (tempRow >= 0 && tempRow < this.games.height && // check if the index is in the gird\n                tempCol >= 0 && tempCol < this.games.width) {\n                neighbors.push(tempIndex);\n            }\n        }\n        \n        return neighbors;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        // TODO: futher optimizations \n        // TODO: Render screen differences only, not the whole new state.\n        this.drawBackground(ctx);\n        this.drawBoard(ctx, canvasWindow);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        const gradient1 = ctx.createLinearGradient(this.width / 2,\n            this.height, this.width / 2, 0);\n        gradient1.addColorStop(0.05, '#333');\n        gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 50%, 1)`);\n        ctx.fillStyle = gradient1;\n        ctx.fillRect(0, 0, this.width, this.height);\n        ctx.restore();\n    }\n\n    private drawBoard(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        const totalPieceSize = this.settings.defaultCellSize + this.settings.gridGapSize;\n        const startingColOffset = Math.max(this.width, canvasWindow.width) - canvasWindow.width;\n        const startingRowOffset = Math.max(this.height, canvasWindow.height) - canvasWindow.height;\n\n        const startingRow = Math.floor(canvasWindow.x / (totalPieceSize + startingColOffset + 1));\n        const startingCol = Math.floor(canvasWindow.y / (totalPieceSize + startingRowOffset + 1));\n\n        const endingCol = Math.min(Math.ceil(\n            (canvasWindow.x + canvasWindow.width - this.offsetWidth) / totalPieceSize) + 1,\n            this.games.width);\n        const endingRow = Math.min(Math.ceil(\n            (canvasWindow.y + canvasWindow.height - this.offsetHeight) / totalPieceSize) + 1,\n            this.games.height);\n\n        for (let row = startingRow; row < endingRow; row++) {\n            for (let col = startingCol; col < endingCol; col++) {\n                // position\n                const x = this.offsetWidth + this.calculateBoardSize(col);\n                const y = this.offsetHeight + this.calculateBoardSize(row);\n                const index = this.getIndex(row, col);\n                const cell = this.grid[index];\n\n                /**\n                 * This is what I want to be able to call\n                 */\n                if (cell) {\n                    this.pieceRenderer.drawPiece(ctx, cell, x, y);\n                }\n            }    \n        }\n    }\n\n    private calculateBoardSize(size: number) {\n        return (size * this.settings.defaultCellSize) + ((size + 1) * this.settings.gridGapSize)\n    }\n}\n","import { Point2d } from \"../models/GameTypes\";\n\nexport default function InSquare(square: {\n    top: number,\n    left: number,\n    size: number,\n}, point: Point2d): boolean {\n    return point.y >= square.top && point.y <= square.top + square.size &&\n        point.x >= square.left && point.x <= square.left + square.size\n}","import { SimpleEventState } from \"../models/EventTypes\";\nimport { Point2d } from \"../models/GameTypes\";\n\ninterface Listener {\n    element: HTMLElement;\n    listeningTo: Array<keyof HTMLElementEventMap>;\n}\n\n// why not use\n// https://reactjs.org/docs/events.html#pointer-events\nexport default class InputController {\n\n    private listeners: { [key: number]: Listener } = {};\n    private timer: number = 0;\n    private touchTimer: number = 0;\n    private touchThreshold: number = 300;\n    private touchPoint?: Point2d;\n    private idCounter: number = 0;\n\n    private state?: SimpleEventState;\n\n    /**\n     * Place event listeners on a html element\n     * \n     * @param {HTMLElement} element element events to be placed on\n     * @param {String[]} events events to subscribe to\n     * @returns {number} id that tracks your current input session\n     */\n    public start(element: HTMLElement, events: Array<keyof HTMLElementEventMap>): number {\n        // add to listeners\n        const id = this.uniqueId();\n        this.listeners[id] = {\n            element,\n            listeningTo: []\n        };\n\n        events.forEach((event) => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.addEventListener(event, pointer as any);\n            }\n            else {\n                this.listeners[id].element.addEventListener(event, pointer as any, {\n                    passive: event !== \"contextmenu\",\n                });\n            }\n            this.listeners[id].listeningTo.push(event);\n        });\n\n        return id;\n    }\n\n    /**\n     * Get all event that happened\n     * \n     * Remember to call flush() or else you will get old events that persisted\n     * between frames\n     * \n     * @param {number} id - The events binded to the element you want\n     * @returns {Point2d | null} returns mouses new position or null if the \n     *      mouse hasn't moved since last checked\n     */\n    public pollEvents(id: number): SimpleEventState | undefined {\n        if (this.state) {\n            const rect = this.listeners[id].element.getBoundingClientRect();\n            this.state.pos.x -= rect.left;\n            this.state.pos.y -= rect.top;\n        }\n        return this.state;\n    }\n\n    /**\n     * Remove all of the input state from the controller\n     * @returns {void} \n     */\n    public flush() {\n        this.state = undefined;\n    }\n\n    public stop(id: number): boolean {\n        if (this.listeners[id] === undefined) {\n            return false;\n        }\n\n        this.listeners[id].listeningTo.forEach(event => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.removeEventListener(event, pointer as any);\n            } else {\n                this.listeners[id].element.removeEventListener(event, pointer as any);\n            }\n        });\n\n        return true;\n    }\n\n    private getFunctionPointer(eventType: keyof HTMLElementEventMap) {\n        switch (eventType) {\n            case \"mousemove\": return this.mouseEvent;\n            case \"mousedown\": return this.mouseEvent;\n            case \"mouseup\": return this.mouseEvent;\n            case \"contextmenu\": return this.stopContextMenu;\n            case \"touchstart\": return this.touchEvent;\n            case \"touchmove\": return this.touchEvent;\n            case \"touchend\": return this.touchEvent;\n            case \"keydown\": return this.keydownEvent;\n        }\n    }\n\n    private mouseEvent = (event: MouseEvent) => {\n        if (this.touchPoint) { // this means touch is active\n            return;\n        }\n        if (this.state && this.state.events.includes(\"touch\")) {\n            return;\n        }\n        if (this.state) {\n            this.state.events.push(event.type as any);\n            return;\n        }\n        this.state = {\n            leftClick: [1, 3, 5, 7].includes(event.buttons),\n            middleClick: [4, 5, 6, 7].includes(event.buttons),\n            rightClick: [2, 3, 6, 7].includes(event.buttons),\n            pos: {\n                x: event.pageX,\n                y: event.pageY,\n            },\n            keys: (this.state) ? this.state!.keys : [],\n            events: [event.type as any]\n        };\n    }\n\n    private stopContextMenu = (event: any) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    }\n\n    private touchEvent = (event: TouchEvent) => {\n        if (event.type === \"touchstart\") {\n            if (this.touchTimer === 0) {\n                this.timer = Date.now();\n            }\n            this.touchPoint = {\n                x: event.targetTouches[0].pageX,\n                y: event.targetTouches[0].pageY,\n            };\n            return;\n        }\n\n        if (event.type === \"touchmove\") {\n            this.touchPoint = undefined;\n            return;\n        }\n\n        if (event.type === \"touchend\" && this.touchPoint) {\n            const delta = Date.now() - this.timer;\n            this.timer = Date.now();\n            this.touchTimer += delta;\n            this.state = {\n                leftClick: this.touchTimer < this.touchThreshold,\n                middleClick: false,\n                rightClick: this.touchTimer > this.touchThreshold,\n                pos: this.touchPoint!,\n                keys: (this.state) ? this.state!.keys : [],\n                events: [\"touch\"]\n            }\n            this.touchPoint = undefined;\n            this.touchTimer = 0;\n        }\n    }\n\n    private keydownEvent = (event: KeyboardEvent) => {\n        if(this.state) {\n            this.state.events.push(event.type as any);\n        }\n        if (this.state) {\n            this.state.keys.push(event.key);\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1 },\n                keys: [event.key],\n                events: [event.type as any]\n            };\n        }\n    }\n\n    private uniqueId() {\n        return this.idCounter++;\n    }\n}\n","import React from 'react';\nimport toHHMMSS from '../util/toHHMMSS';\nimport piece from \"../assets/piece.svg\";\nimport hourglass from \"../assets/hourglass.svg\";\nimport \"./Header.css\"\nimport { Link } from 'react-router-dom';\n\ninterface Props {\n    time: number;\n    left: number;\n    pieces: number;\n}\n\nconst GameHeader: React.FC<Props> = (props: Props) => {\n    return <header className=\"header  header--game\">\n        <div className=\"header__detail\" >\n            <img src={piece} alt=\"Home\" />\n            <span>{props.left}/{props.pieces}</span>\n        </div>\n        <h3>\n            <Link to=\"/\">BombFinder</Link>\n        </h3>\n        <div className=\"header__detail\">\n            <span>{toHHMMSS(props.time)}</span>\n            <img src={hourglass} alt=\"Home\" />\n        </div>\n    </header>\n}\n\nexport default GameHeader;","import React from 'react';\nimport \"./Switch.css\";\n\ninterface Props {\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Switch: React.FC<Props> = (props: Props) => {\n    return <label className=\"switch\">\n        <input\n            checked={props.checked}\n            onChange={props.onChange}\n            className=\"switch__input\"\n            type=\"checkbox\" />\n        <span className=\"switch__box\">\n            <span className=\"switch__marker\" />\n        </span>\n    </label>\n}\n\nexport default Switch;","import React from 'react';\nimport info from \"../assets/info.svg\";\nimport settings from \"../assets/cog-f.svg\";\nimport { Link } from 'react-router-dom';\nimport \"./Footer.css\"\nimport Switch from './Switch';\n\ninterface Props {\n    isSwitchChecked?: boolean;\n    flagToggle: (value: boolean) => void;\n}\n\nconst GameFooter: React.FC<Props> = (props: Props) => {\n    const isChecked = (props.isSwitchChecked) ? true : false;\n    return (\n        <footer className=\"footer footer--game\">\n            <Link to=\"/how-to-play\">\n                <img src={info} alt=\"Info\" />\n            </Link>\n            <div className=\"footer__text\">\n                <span>Clear</span>\n                <Switch\n                    checked={isChecked}\n                    onChange={(event: any) => props.flagToggle(event.target.checked) }/>\n                <span>Flag</span>\n            </div>\n            <Link to=\"/settings\">\n                <img src={settings} alt=\"Settings\" />\n            </Link>\n        </footer>\n    );\n}\n\nexport default GameFooter;","import React, { Component } from 'react';\nimport BombFinder from \"../logic/BombFinder\";\nimport InputController from \"../logic/InputController\";\nimport { Redirect } from 'react-router-dom';\nimport { GameProgress } from '../models/GameTypes';\nimport { CanvasWindow } from '../logic/BombFinderPieceRenderer';\nimport Games from '../models/Games';\nimport Loading from './Loading';\nimport Preferences from '../models/Preferences';\nimport Button from './Button';\nimport GameHeader from './Gameheader';\nimport GameFooter from './GameFooter';\nimport './GameBoard.css';\n\ninterface Props {\n    id: string;\n    onGameFinished: (result: GameProgress) => void\n}\n\ninterface State {\n    ready: boolean;\n    gameOver: boolean;\n    canVibrate: boolean;\n    canTryAgain: boolean;\n    toMainMenu: boolean;\n    totalPieces: number;\n    newGameId?: string;\n    inputId?: number;\n    time: number;\n}\n\nclass GameBoard extends Component<Props, State> {\n\n    private stopUpdates: boolean = false;\n    private rafId?: number;\n    private lastFrame: number = 0;\n\n    private container?: HTMLDivElement;\n    private canvas?: HTMLCanvasElement;\n    // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#Turn_off_transparency\n    private context2D?: CanvasRenderingContext2D;\n    private gameState?: BombFinder;\n    private input?: InputController;\n\n    state: Readonly<State> = {\n        ready: false,\n        gameOver: false,\n        canVibrate: false,\n        canTryAgain: false,\n        toMainMenu: false,\n        totalPieces: 0,\n        time: 0,\n    }\n\n    public componentDidUpdate(prevProps: Props, prevState: State) {\n        if (prevState.newGameId && prevProps.id !== prevState.newGameId) {\n            // new game has started without unmounting the component\n            this.setState({\n                ready: false,\n                gameOver: false,\n                canTryAgain: false,\n                time: 0,\n                newGameId: undefined,\n                inputId: undefined,\n            });\n            this.destroyGame();\n            this.createGame();\n        }\n    }\n\n    public async componentDidMount() {\n        this.createGame();\n    }\n\n    public componentWillUnmount() {\n        this.stopUpdates = true;\n        this.destroyGame();\n    }\n\n    public async createGame() {\n        // TODO: GetById error handling\n        const games = await Games.GetById(this.props.id)!;\n        const preferences = await Preferences.GetPreferences();\n        const page = document.getElementById(\"page\") as HTMLDivElement;\n        if (games.result === \"won\") {\n            this.props.onGameFinished(games.result);\n            return;\n        }\n        // TODO: Remove magic number\n        this.gameState = new BombFinder(games, preferences, page.clientWidth, page.clientHeight - 120);\n        this.input = new InputController();\n        this.setState({ ready: true, totalPieces: games.totalPieces });\n        this.canvas = document.getElementById(\"board\") as HTMLCanvasElement;\n        this.container = document.getElementById(\"board-container\") as HTMLDivElement;\n        this.context2D = this.canvas.getContext(\"2d\")!;\n\n        const inputId = this.input.start(this.canvas!, [\"mousemove\", \"mousedown\",\n            \"contextmenu\", \"touchstart\", \"touchmove\", \"touchend\", \"keydown\"]);\n\n        // TODO: Add error handling\n        this.canvas!.width = this.gameState!.gameBoardWidth;\n        this.canvas!.height = this.gameState!.gameBoardHeight;\n        this.container.scrollLeft = (this.gameState!.gameBoardWidth - window.innerWidth) / 2;\n        this.setState({ ready: true, inputId: inputId, canVibrate: preferences.vibration });\n        requestAnimationFrame(this.draw);\n    }\n\n    public destroyGame() {\n        if (this.state.ready && this.state.inputId) {\n            this.input!.stop(this.state.inputId!);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId!);\n        }\n    }\n\n    public changeInputMode = (markFlag: boolean) => {\n        this.gameState!.setMarkInput(markFlag);\n        // this.gameState!.draw(this.context2D!);\n    }\n\n    public tryAgain = async () => {\n        if (this.state.ready && !this.state.newGameId && this.state.canTryAgain) {\n            try {\n                const newGameId = await this.gameState!.reset();\n                this.setState({ ready: false, newGameId });\n            } catch (e) {\n                console.warn(\"error \" + e);\n                // TODO: implement Error handling\n            }\n        }\n    }\n\n    public goToMainMenu = async () => {\n        if (this.state.ready) {\n            const logged = await this.gameState!.logAndDestory();\n            if (logged) {\n                this.setState({toMainMenu: true});\n            }\n        }\n    }\n\n    public render() {\n        if (this.state.toMainMenu) {\n            return <Redirect to=\"/\" />;\n        }\n        if (this.state.newGameId) {\n            const route = `/game/${this.state.newGameId}`;\n            return <Redirect to={route} />;\n        }\n        if (!this.state.ready) {\n            return <Loading />\n        }\n        const dimensions = {\n            height: this.gameState!.gameBoardHeight,\n            width: this.gameState!.gameBoardWidth,\n        };\n        let canvasBoardClass = \"board__canvas \" + this.gameState!.gameBoardOverflowClasses;\n        return (\n            <div className=\"board\">\n                <GameHeader time={this.gameState!.getTime}\n                    left={this.gameState!.getRemainingAvailablePiece}\n                    pieces={this.state.totalPieces}/>\n                <div className={canvasBoardClass} id=\"board-container\">\n                    <canvas id=\"board\"\n                        className={this.gameState!.gameState}\n                        width={dimensions.width}\n                        height={dimensions.height} />\n                    {(this.state.gameOver)\n                        ? <div className=\"board__popup\">\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Try Again\"\n                                onClick={this.tryAgain} />\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Main Menu\"\n                                onClick={this.goToMainMenu} />\n                        </div>\n                        : null\n                    }\n                </div>\n                <GameFooter\n                    isSwitchChecked={!this.gameState!.isInputModeToggle}\n                    flagToggle={this.changeInputMode} />\n            </div>\n        );\n    }\n\n    private draw = (delta: number) => {\n        if (!this.state.ready) {\n            // TODO: do we need this ready check for the game?????\n            return;\n        }\n        const elapsedTime = delta - this.lastFrame;\n        const events = this.input!.pollEvents(this.state.inputId!);\n        \n        if (events) {\n            this.gameState!.handleEvents(events);\n            if (events.keys.length > 0) {\n                this.forceUpdate();\n            }\n        }\n        this.gameState!.update(elapsedTime);\n        // TODO: calcuate playing area and send it to draw\n        const viewport: CanvasWindow = {\n            x: this.container!.scrollLeft, y: this.container!.scrollTop,\n            width: this.container!.clientWidth, height: this.container!.clientHeight\n        };\n        this.gameState!.draw(this.context2D!, viewport);\n        \n        // Initial draw call before any events\n        if (this.rafId === undefined || this.gameState!.isGameOver) {\n            this.gameState!.draw(this.context2D!, viewport);\n        }\n        \n        this.input!.flush();\n        \n        \n        if (this.gameState!.isGameOver) {\n            this.lastFrame = delta;\n            if (this.gameState!.isGameWon) {\n                this.props.onGameFinished(\"won\");\n            } else {\n                if (this.state.canVibrate && navigator.vibrate) {\n                    navigator.vibrate(200);\n                }\n                this.setState({\n                    gameOver: true,\n                    canVibrate: false,\n                    canTryAgain: true,\n                });\n            }\n        }\n\n        if (!this.stopUpdates) {\n            this.rafId = requestAnimationFrame(this.draw);\n            this.lastFrame = delta;\n            if (this.state.time !== this.gameState!.getTime) {\n                this.setState({ time: this.gameState!.getTime });\n            }\n        }\n    }\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport { GameProgress } from '../models/GameTypes';\nimport GameBoard from '../components/GameBoard';\nimport { RouteComponentProps, Redirect } from 'react-router';\nimport Games from '../models/Games';\nimport PageNotFound from './page-not-found';\n\ninterface ParamProps {\n    id: string;\n}\n\ntype Props = RouteComponentProps<ParamProps>;\n\ninterface State {\n    // for when the game is done\n    to404Page: boolean;\n    toWonPage: boolean;\n    redirecting: boolean;\n    ready: boolean;\n}\n\nexport default class Game extends Component<Props, State> {\n\n    state: Readonly<State> = {\n        to404Page: false,\n        toWonPage: false,\n        redirecting: false,\n        ready: false,\n    }\n\n    async componentDidMount() {\n        const exists = await Games.DoesGameExists(this.props.match.params.id);\n        if (exists) {\n            this.setState({ to404Page: false, ready: true });\n        }\n        else {\n            this.setState({ to404Page: true, ready: true });\n        }\n    }\n\n    gameFinished = (result: GameProgress) => {\n        this.setState({ toWonPage: result === \"won\" });\n    }\n\n    public render() {\n        if (this.state.toWonPage) {\n            return <Redirect to={`/game/${this.props.match.params.id}/game-won`} />\n        }\n        else if (this.state.to404Page) {\n            return <PageNotFound />;\n        }\n        else if (this.state.ready) {\n            return <GameBoard\n                id={this.props.match.params.id}\n                onGameFinished={this.gameFinished} />\n        } else {\n            return null;\n        }\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","\nexport enum LoopOptions {\n    REPEAT,\n    ALTERNATE,\n    STOP\n}\n\nexport default class AnimationTimer {\n\n    private playing: boolean;\n    private timer = 0;\n    private target: number;\n    private step: number;\n    private loop: LoopOptions;\n    private alternated: boolean;\n\n    constructor(target: number, step: number, loop: LoopOptions = LoopOptions.STOP) {\n        this.timer = 0;\n        this.target = target;\n        this.step = step;\n        this.loop = loop;\n        this.alternated = false;\n        this.playing = true;\n    }\n\n    update(delta: number) {\n        if (!this.isComplete() && this.playing) {\n            this.timer += this.step;\n        } else {\n            if (this.loop === LoopOptions.REPEAT) {\n                this.timer = this.timer % this.target;\n            } else if (this.loop === LoopOptions.ALTERNATE) {\n                this.setStep(this.step * -1);\n                if (!this.alternated) {\n                    this.timer = 0;\n                } else {\n                    this.timer = this.target;\n                }\n            } else if (this.loop === LoopOptions.STOP) {\n                this.timer = this.target;\n                this.stop();\n            }\n        }\n    }\n\n    public stop() {\n        this.playing = false;\n    }\n\n    public play() {\n        this.playing = true;\n    }\n\n    public getValue() {\n        return this.timer;\n    }\n\n    public setTarget(target: number) {\n        this.target = target;\n    }\n\n    public setStep(step: number) {\n        if (step < 0) {\n            this.alternated = true;\n        } else {\n            this.alternated = false;\n        }\n        this.step = step;\n    }\n\n    public isComplete() {\n        return (this.alternated)\n            ? this.timer <= 0\n            : this.timer >= this.target;\n    }\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","export default function toHHMMSS(time: number) {\n    time = Math.floor(time);\n    const hours = Math.floor(time / 3600);\n    const minutes = Math.floor((time - (hours * 3600)) / 60);\n    const seconds = time - (hours * 3600) - (minutes * 60);\n    let timeString = \"\";\n\n    if (hours > 0) {\n        timeString += (hours < 10) ? `0${hours}` : `${hours}`;\n    }\n    timeString += (minutes < 10) ? `0${minutes}:` : `${minutes}:`;\n    timeString += (seconds < 10) ? `0${seconds}` : `${seconds}`;\n\n    return timeString;\n}","import AnimationTimer, { LoopOptions } from \"./Animation\";\nimport { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    private pieceAnimations: AnimationTimer[] = [];\n\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.pieceLength = settings.defaultCellSize;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = this.pieceLength + 2;\n        this.invisiblePieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, 1, 1);\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = this.pieceLength + 2;\n        this.invisibleMarkedPieceCanvas.width = this.pieceLength + 2;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, 1, 1, \"#3396ff\");\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = this.pieceLength + 2;\n            this.staticPieceCanvas[i].height = this.pieceLength + 2;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 1, 1.5, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 1, 1.5, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 1, 1.5, 0);\n            } else {\n                this.drawVisibleCell(ctx, 1, 1.5, undefined);\n            }\n        }\n    }\n\n    setCellSize(value: number) {\n        this.pieceLength = value;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, \"#3396ff\");\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(\n                new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    update(delta: number) {\n        if (this.simpleRender) {\n            return;\n        }\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            this.pieceAnimations[i].update(delta);\n        }\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        ipcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        impcContext.clearRect(0, 0, this.pieceLength, this.pieceLength);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, 1, 1);\n        this.drawInvisiblePiece(impcContext, 1, 1, \"#3396ff\");\n    }\n\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, \"#3396ff\"); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, \"#3396ff\"); break;\n        }\n        ctx.restore();\n    }\n\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                this.drawHover(ctx, x + 1, y + 1);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n\n        if (this.simpleRender) {\n            return;\n        }\n\n        ctx.save();\n        let s = this.pieceLength;\n        let jump = 0;\n        for (let i = 1; i < this.pieceAnimations.length; i++) {\n            const rotation = (i % 2 === 0) ? 1 : -1;\n            this.drawRotatingSquare(ctx, jump + x, jump + y, s, i, rotation, overrideColor);\n            jump += (s / 4) / 2;\n            s = (s / 4) * 3;\n        }\n        ctx.restore();\n    }\n\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotationDirection: 1 | -1, overrideColor?: string) {\n        const radius = cellLength / 8;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - (radius);\n        let y = worldY + cellLength / 4 - (radius);\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + totalLength / 2, y + totalLength / 2);\n        ctx.rotate(this.pieceAnimations[i].getValue() *  Math.PI / 180);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawRectangle(ctx, x, y, radius, totalLength);\n        ctx.lineWidth = 2;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"gray\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    private drawRectangle(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        let alpha = 1.0;\n        for (let i = 1; i <= (this.gapSize / 2); i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawRectangle(ctx, x - i, y - i, (this.pieceLength) / 8,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= 0.1;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawRectangle(ctx, x, y, this.pieceLength / 8, this.pieceLength);\n            ctx.lineWidth = 3;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + 2;\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = 2;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}","module.exports = __webpack_public_path__ + \"static/media/hourglass.63a5448b.svg\";","import React from 'react';\nimport \"../components/Button.css\"\nimport \"./page-not-found.css\"\nimport { Link } from 'react-router-dom';\n\nconst PageNotFound: React.FC = () => {\n    return <div className=\"page-not-found\">\n        <h1>404</h1>\n        <div className=\"page-not-found__message\">\n            Looks like you've lost your way\n        </div>\n        <Link to=\"/\" className=\"link-button page-not-found__btn\">\n            Go Home\n        </Link>\n    </div>\n}\n\nexport default PageNotFound;","module.exports = __webpack_public_path__ + \"static/media/piece.e03fada0.svg\";"],"sourceRoot":""}