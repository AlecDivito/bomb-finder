{"version":3,"sources":["models/GameTypes.ts","logic/Animation.ts","logic/BombFinder.ts","util/InSquare.ts","logic/InputController.ts","components/Gameheader.tsx","components/Switch.tsx","components/GameFooter.tsx","components/GameBoard.tsx","pages/game.tsx","components/Button.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","models/GameBoardTypes.ts","util/Random.ts","logic/BombFinderPieceRenderer.ts","util/toHHMMSS.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js","models/Preferences.ts","assets/hourglass.svg","pages/page-not-found.tsx","assets/piece.svg"],"names":["InputMode","GameStatus","LoopOptions","AnimationTimer","target","step","loop","arguments","length","undefined","STOP","Object","classCallCheck","this","playing","timer","alternated","delta","isComplete","REPEAT","ALTERNATE","setStep","stop","BombFinder","games","settings","minWidth","minHeight","pieceRenderer","grid","updateRemainingPiecesCount","remainingPieces","inputMode","TOGGLE","backgroundAnimation","height","width","offsetWidth","offsetHeight","overflowClasses","BombFinderPieceRenderer","calculatedWidth","calculateBoardSize","calculatedHeight","setMarkInput","init","markFlag","MARK","setTarget","play","reset","newGame","id","Error","logAndDestroy","update","gameHasStarted","totalPieces","calcDelta","time","reduce","total","cell","isVisible","visibility","isBomb","value","invisiblePieces","result","forEach","state","CellState","BOMB","Visibility","VISIBLE","board","events","includes","keys","hover","index","getIndexByPixel","pos","leftClick","INVISIBLE","totalMoves","firstMoveHandicap","repositionBombCell","toggleCell","setCellVisibility","rightClick","isMarkable","MARKED","markCell","_this","newIndex","bombs","area","RandInRange","getNeighbors","cellIndex","objectSpread","incrementCellValue","pieces","CLEAN","decrementCellValue","constructGrid","neighbors","visited","i","pop","isMarked","push","_this2","neighbor","_this3","pre","VISIBLY_SATISFIED","point","cellSize","gridGapSize","defaultCellSize","row","Math","floor","y","col","x","top","left","square","size","InSquare","getIndex","bombCounter","defaultCell","random","bombProximityCounter","neighborIndex","j","tempRow","tempCol","tempIndex","ctx","canvasWindow","drawBackground","drawBoard","save","gradient1","createLinearGradient","addColorStop","vibrantColors","concat","getValue","fillStyle","fillRect","restore","totalPieceSize","startingColOffset","max","startingRowOffset","startingRow","startingCol","endingCol","min","ceil","endingRow","drawPiece","InputController","listeners","touchTimer","touchThreshold","touchPoint","idCounter","previousState","mouseEvent","event","type","buttons","middleClick","pageX","pageY","stopContextMenu","preventDefault","stopPropagation","touchEvent","Date","now","targetTouches","keydownEvent","key","doubleClickEvent","element","uniqueId","listeningTo","pointer","getFunctionPointer","window","addEventListener","passive","rect","getBoundingClientRect","removeEventListener","eventType","GameHeader","props","react_default","a","createElement","className","src","piece","alt","react_router_dom","to","toHHMMSS","hourglass","Switch","checked","onChange","GameFooter","isChecked","isSwitchChecked","info","src_components_Switch","flagToggle","GameBoard","stopUpdates","rafId","container","canvas","context2D","gameState","input","ready","gameOver","canVibrate","canTryAgain","toMainMenu","remainingAvailablePiece","changeInputMode","forceUpdate","tryAgain","_callee","newGameId","regenerator_default","wrap","_context","prev","next","sent","setState","t0","console","warn","goToMainMenu","_callee2","_context2","draw","pollEvents","inputId","handleEvents","viewport","scrollLeft","scrollTop","clientWidth","clientHeight","isGameOver","flush","isGameWon","onGameFinished","navigator","vibrate","getRemainingAvailablePiece","requestAnimationFrame","getTime","prevProps","prevState","destroyGame","createGame","Games","GetById","Preferences","GetPreferences","preferences","page","document","getElementById","getContext","start","gameBoardWidth","gameBoardHeight","innerWidth","innerHeight","vibration","cancelAnimationFrame","react_router","route","Loading","dimensions","canvasBoardClass","gameBoardOverflowClasses","Gameheader","Button","text","onClick","components_GameFooter","isInputModeToggle","Component","Game","to404Page","toWonPage","redirecting","gameFinished","DoesGameExists","match","params","page_not_found","src_components_GameBoard","react__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_ref","disabled","disabledClass","classes","_defineProperty","obj","defineProperty","enumerable","configurable","writable","d","__webpack_exports__","v","cv","_home_divitoa_Program_JS_bombfinder_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","RECTANGLE_REDIS_DEGREE","LINE_WIDTH_DEGREE","ROTATING_LINE_WIDTH_DEGREE","PIECE_MARKED_COLOR","invisiblePieceCanvas","invisibleMarkedPieceCanvas","staticPieceCanvas","pieceAnimations","lineWidth","pieceLength","gapSize","simpleRender","exampleCellValue","reverseTiming","setSpinningCubes","spinningCubes","drawInvisiblePiece","drawVisibleCell","num","reverse","oldTime","newTime","sin","every","b","ipcContext","impcContext","clearRect","drawImage","offset","drawHover","getIndexByCell","overrideColor","s","rotation","pow","drawRotatingSquare","beginPath","strokeStyle","drawSquare","stroke","closePath","worldX","worldY","cellLength","radius","totalLength","translate","rotate","moveTo","lineTo","quadraticCurveTo","alpha","cellValue","arc","PI","innerX","innerY","gradient","createRadialGradient","fill","font","ypos","xpos","textAlign","textBaseline","fillText","String","hours","minutes","seconds","timeString","_objectSpread","_defineProperty__WEBPACK_IMPORTED_MODULE_0__","source","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","Table","Field","tableName","Query","getById","cachedSettings","timestamp","assign","module","exports","p","r","react_router_dom__WEBPACK_IMPORTED_MODULE_3__","PageNotFound"],"mappings":"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","file":"static/js/3.bfd432f1.chunk.js","sourcesContent":["export enum InputMode {\n    TOGGLE,\n    MARK,\n}\n\nexport interface Point2d {\n    x: number;\n    y: number;\n}\n\nexport enum GameStatus {\n    GAME_PAUSED,\n    GAME_PLAY,\n}\n\nexport type GameDifficulty = \"easy\" | \"medium\" | \"hard\" | string;\n\nexport type GameProgress = \"created\" | \"inprogress\" | \"lost\" | \"won\";\n\n","\nexport enum LoopOptions {\n    REPEAT,\n    ALTERNATE,\n    STOP\n}\n\nexport default class AnimationTimer {\n\n    private playing: boolean;\n    private timer = 0;\n    private target: number;\n    private step: number;\n    private loop: LoopOptions;\n    private alternated: boolean;\n\n    constructor(target: number, step: number, loop: LoopOptions = LoopOptions.STOP) {\n        this.timer = 0;\n        this.target = target;\n        this.step = step;\n        this.loop = loop;\n        this.alternated = false;\n        this.playing = true;\n    }\n\n    update(delta: number) {\n        if (!this.isComplete() && this.playing) {\n            this.timer += this.step;\n        } else {\n            if (this.loop === LoopOptions.REPEAT) {\n                this.timer = this.timer % this.target;\n            } else if (this.loop === LoopOptions.ALTERNATE) {\n                this.setStep(this.step * -1);\n                if (!this.alternated) {\n                    this.timer = 0;\n                } else {\n                    this.timer = this.target;\n                }\n            } else if (this.loop === LoopOptions.STOP) {\n                this.timer = this.target;\n                this.stop();\n            }\n        }\n    }\n\n    public stop() {\n        this.playing = false;\n    }\n\n    public play() {\n        this.playing = true;\n    }\n\n    public getValue() {\n        return this.timer;\n    }\n\n    public setTarget(target: number) {\n        this.target = target;\n    }\n\n    public setStep(step: number) {\n        if (step < 0) {\n            this.alternated = true;\n        } else {\n            this.alternated = false;\n        }\n        this.step = step;\n    }\n\n    public isComplete() {\n        return (this.alternated)\n            ? this.timer <= 0\n            : this.timer >= this.target;\n    }\n}","import { Cell, CellState, CellValue, Visibility, isVisible, isBomb, isMarkable, isMarked, incrementCellValue, decrementCellValue } from \"../models/GameBoardTypes\";\nimport { SimpleEventState } from \"../models/EventTypes\";\nimport InSquare from \"../util/InSquare\";\nimport { Point2d, InputMode } from \"../models/GameTypes\";\nimport Games from \"../models/Games\";\nimport { IPreferences } from \"../models/Preferences\";\nimport AnimationTimer from \"./Animation\";\nimport BombFinderPieceRenderer, { CanvasWindow } from \"./BombFinderPieceRenderer\";\nimport RandInRange from \"../util/Random\";\n\nexport default class BombFinder {\n\n    // template data\n    private games: Games;\n    private settings: IPreferences;\n    private pieceRenderer: BombFinderPieceRenderer;\n\n    // game play\n    private grid: Cell[] = [];\n    private updateRemainingPiecesCount: boolean = false;\n    private remainingPieces: number = 0;\n    private inputMode: InputMode = InputMode.TOGGLE;\n\n    // animations\n    private readonly backgroundAnimation: AnimationTimer;\n\n    // canvas data\n    private readonly height: number;\n    private readonly width: number;\n    private readonly offsetWidth: number;\n    private readonly offsetHeight: number;\n    private readonly overflowClasses: string = \"\";\n\n    constructor(games: Games, settings: IPreferences, minWidth: number, minHeight: number) {\n        this.games = games;\n        this.settings = settings;\n        this.pieceRenderer = new BombFinderPieceRenderer(settings);\n\n        const calculatedWidth = this.calculateBoardSize(this.games.width);\n        const calculatedHeight = this.calculateBoardSize(this.games.height);\n\n        if (minWidth > calculatedWidth) {\n            this.width = minWidth;\n            this.offsetWidth = (this.width - calculatedWidth) / 2;;\n        } else {\n            this.overflowClasses += \" overflow-x\"; \n            this.width = calculatedWidth;\n            this.offsetWidth = 0;\n        }\n\n        if (minHeight > calculatedHeight) {\n            this.height = minHeight;\n            this.offsetHeight = (this.height - calculatedHeight) / 2;\n        } else {\n            this.overflowClasses += \" overflow-y\"; \n            this.height = calculatedHeight;\n            this.offsetHeight = 0;\n        }\n        this.backgroundAnimation = new AnimationTimer(121, 3);            \n        this.setMarkInput();\n\n        this.init();\n    }\n\n    public get isInputModeToggle() {\n        return InputMode.TOGGLE === this.inputMode;\n    }\n\n    public get gameBoardOverflowClasses() {\n        return this.overflowClasses;\n    }\n\n    public get gameBoardWidth() {\n        return this.width;\n    }\n\n    public get gameBoardHeight() {\n        return this.height;\n    }\n\n    public get gameState() {\n        return this.games.result;\n    }\n\n    public get isGameOver() {\n        return this.games.result === \"lost\" || this.games.result === \"won\";\n    }\n\n    public get isGameWon() {\n        return this.games.result === \"won\";\n    }\n\n    public get getRemainingAvailablePiece() {\n        return this.remainingPieces;\n    }\n\n    public get getTime() {\n        return Math.floor(this.games.time);\n    }\n\n    public setMarkInput(markFlag: boolean = false) {\n        this.inputMode = (markFlag) ? InputMode.MARK : InputMode.TOGGLE;\n        if (this.inputMode === InputMode.MARK) {\n            this.backgroundAnimation.setTarget(121);\n            this.backgroundAnimation.setStep(3);\n            this.backgroundAnimation.play();\n        } else if (this.inputMode === InputMode.TOGGLE) {\n            this.backgroundAnimation.setTarget(0);\n            this.backgroundAnimation.setStep(-3);\n            this.backgroundAnimation.play();\n        }\n    }\n\n    public async reset(): Promise<string> {\n        const newGame = await this.games.reset(this.games);\n        if (newGame) {\n            return newGame.id;\n        }\n        throw new Error(\"Had a problem saving old Game\");\n    }\n\n    public async logAndDestroy() {\n        return await this.games.logAndDestroy();\n    }\n\n    public update(delta: number) {\n        if (this.games.isComplete) {\n            return;\n        }\n        this.pieceRenderer.update(delta);\n        this.backgroundAnimation.update(delta);\n        if (this.games.gameHasStarted && this.remainingPieces !== this.games.totalPieces) {\n            const calcDelta = delta;\n            this.games.time += calcDelta;\n        }\n        if (this.updateRemainingPiecesCount) {\n            this.remainingPieces = this.grid.reduce((total, cell) =>\n                (isVisible(cell.visibility) && !isBomb(cell.value)) ? total - 1 : total\n            , this.games.totalPieces);\n            this.updateRemainingPiecesCount = false;\n            this.games.invisiblePieces = this.remainingPieces;\n            this.games.update();\n        }\n        if (!this.games.isComplete && (this.games.result === \"lost\" || this.remainingPieces === 0)) {\n            this.grid.forEach((cell) => {\n                if (cell.state === CellState.BOMB) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n            this.games.board = this.grid;\n            if (this.games.result === \"lost\") {\n                this.games.result = \"lost\";\n                this.games.update();\n            }\n            else if (this.remainingPieces === 0) {\n                this.games.result = \"won\";\n                this.games.update();\n            }\n            this.games.isComplete = true;\n        }\n    }\n\n    public handleEvents(events?: SimpleEventState) {\n        if (this.games.result !== \"inprogress\" && this.games.result !== \"created\") {\n            return;\n        }\n        if (!events) {\n            return;\n        }\n        if (events.events.includes(\"dblclick\") || (events.events.includes(\"keydown\") && events.keys.includes(\"f\"))) {\n            this.setMarkInput(this.inputMode === InputMode.TOGGLE);\n        }\n        if (events.events.includes(\"mousemove\")) {\n            this.grid.forEach((cell) => {\n                cell.hover = false;\n            });\n            const index = this.getIndexByPixel(events.pos);\n            if (index !== null && index < this.grid.length && this.grid[index]) {\n                this.grid[index].hover = true;\n            }\n        }\n        if (events.events.includes(\"mousedown\") || events.events.includes(\"touch\")) {\n            this.games.result = \"inprogress\";\n            const index = this.getIndexByPixel(events.pos);\n            if (index === null || index >= this.grid.length) {\n                return;\n            }\n            let cell = this.grid[index];\n            if (this.inputMode === InputMode.TOGGLE && events.leftClick && cell.visibility === Visibility.INVISIBLE) {\n                this.games.totalMoves++;\n                if (isBomb(cell.value) && this.remainingPieces === this.games.totalPieces\n                    && this.settings.firstMoveHandicap) {\n                    // it is impossible to lose on the first move, so move the\n                    // bomb somewhere else\n                    this.repositionBombCell(index);\n                    cell = this.grid[index];\n                } else if (isBomb(cell.value)) {\n                    this.games.result = \"lost\";\n                }\n                if (cell.value === 0) {\n                    this.toggleCell(index);\n                }\n                this.setCellVisibility(index);\n            } else if (events.rightClick || (events.leftClick && this.inputMode === InputMode.MARK)) {\n                this.games.totalMoves++;\n                if (isMarkable(cell.visibility)) {\n                    cell.visibility = (cell.visibility === Visibility.MARKED)\n                        ? Visibility.INVISIBLE\n                        : Visibility.MARKED;\n                    this.markCell(index);\n                }\n            }\n            this.updateRemainingPiecesCount = true;\n        }\n        if (this.games.result === \"lost\") {\n            this.grid.forEach((cell) => {\n                if (isBomb(cell.value)) {\n                    cell.visibility = Visibility.VISIBLE\n                }\n            });\n        }\n    }\n\n    /**\n     * Bomb was clicked on the first turn, therefore we need to re-position the\n     * bomb and calculate the index pieces value\n     *\n     * @param index position of cell inside grid\n     */\n    private repositionBombCell(index: number) {\n        // reposition bomb\n        // check the density of bombs on the board. if the board is too dense\n        // place the new bomb at the first non-bomb tile\n        let newIndex = 0;\n        if ((this.games.bombs / this.games.area) > 0.75) {\n            while (isBomb(this.grid[newIndex].value)) { newIndex++; }\n        } else {\n            do {\n                newIndex = RandInRange(0, this.grid.length - 1);\n            // we don't need to check if the piece is already visible because\n            // no pieces on the board are currently visible\n            } while (isBomb(this.grid[newIndex].value));\n        }\n        this.grid[newIndex] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.BOMB,\n            value: null\n        };\n        const neighbors = this.getNeighbors(newIndex);\n        // update all the neighbors that are not bombs\n        neighbors.forEach( cellIndex => {\n            if (isBomb(this.grid[cellIndex].value)) {\n                return;\n            }\n            this.grid[cellIndex] = {\n                ...this.grid[cellIndex],\n                ...{ value: incrementCellValue(this.grid[cellIndex].value)}\n            };\n        });\n        // create the new cell\n        const pieces = this.getNeighbors(index);\n        const bombs = pieces.reduce((bombs, index) =>\n            isBomb(this.grid[index].value) ? bombs + 1 : bombs\n        , 0);\n        this.grid[index] = {\n            hover: false,\n            visibility: Visibility.INVISIBLE,\n            state: CellState.CLEAN,\n            value: bombs as CellValue\n        };\n        // we also need to decrement all of the neighbors\n        pieces.forEach( cellIndex => {\n            if (isBomb(this.grid[cellIndex].value)) {\n                return;\n            }\n            this.grid[cellIndex] = {\n                ...this.grid[cellIndex],\n                ...{ value: decrementCellValue(this.grid[cellIndex].value) }\n            }\n        });\n    }\n\n    protected init() {\n        this.remainingPieces = this.games.invisiblePieces;\n        if (this.games.board.length === 0) {\n            this.grid = this.constructGrid();\n            this.games.board = this.grid;\n        }\n        else {\n            this.grid = this.games.board;\n        }\n    }\n\n    private toggleCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        const visited: number[] = [index];\n        while (neighbors.length > 0) {\n            const i = neighbors.pop()!;\n            if (this.grid[i].value === 0 && !isMarked(this.grid[i])) {\n                const newNeighbors = this.getNeighbors(i);\n                newNeighbors.forEach((newIndex) => {\n                    if (!neighbors.includes(newIndex) && !visited.includes(newIndex)) {\n                        neighbors.push(newIndex);\n                    }\n                });\n            }\n            this.setCellVisibility(i);\n            visited.push(i);\n        }\n    }\n\n    private markCell(index: number) {\n        const neighbors = this.getNeighbors(index);\n        neighbors.forEach((neighbor) => {\n            const cell = this.grid[neighbor];\n            if (isVisible(cell.visibility) && !isBomb(cell.value) && cell.value !== 0) {\n                this.setCellVisibility(neighbor);\n            }\n        });\n    }\n\n    private setCellVisibility(index: number) {\n        if (isMarked(this.grid[index])) {\n            return;\n        }\n        if (this.grid[index].value === null || this.grid[index].value === 0) {\n            this.grid[index].visibility = Visibility.VISIBLE;\n            return;\n        }\n        const neighbor = this.getNeighbors(index);\n        const count = neighbor.reduce((pre, index) => {\n            const cell = this.grid[index];\n            if (cell.visibility === Visibility.MARKED) {\n                return pre + 1;\n            }\n            return pre;\n        }, 0);\n        if (count >= this.grid[index].value!) {\n            this.grid[index].visibility = Visibility.VISIBLY_SATISFIED\n        } else {\n            this.grid[index].visibility = Visibility.VISIBLE;\n        }\n    }\n\n    private getIndexByPixel(point: Point2d): number | null {\n        const cellSize = this.settings.gridGapSize + this.settings.defaultCellSize;\n        const row = Math.floor((point.y - this.offsetHeight) / cellSize);\n        const col = Math.floor((point.x - this.offsetWidth) / cellSize);\n\n        // check if pointer is inside square\n        const top =  this.offsetHeight + ((row * cellSize) + this.settings.gridGapSize);\n        const left = this.offsetWidth + ((col * cellSize) + this.settings.gridGapSize);\n\n        if (row >= 0 && col >= 0 && col < this.games.width && row < this.games.height &&\n            InSquare({top, left, size: this.settings.defaultCellSize }, point)) {\n            return this.getIndex(row, col);\n        }\n        return null;\n    }\n\n    private getIndex(row: number, col: number): number {\n        return (row * this.games.width) + col;\n    }\n\n    private constructGrid(): Cell[] {\n        const grid: Array<Cell | null> = [];\n\n        // create the grid\n        for (let i = 0; i < this.games.area; i++) {\n            grid.push(null);\n        }\n\n        // place the bombs\n        let bombCounter = this.games.bombs;\n        while (bombCounter > 0) {\n            const defaultCell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.BOMB,\n            }\n            const index = Math.floor(Math.random() * this.games.area);\n\n            if (grid[index] === null) {\n                bombCounter--;\n                grid[index] = defaultCell;\n            }\n        }\n\n        // place safe spaces\n        for (let index = 0; index < grid.length; index++) {\n            if (grid[index] !== null) { // if this is a bomb\n                continue;\n            }\n\n            let bombProximityCounter = 0;\n            const neighbors = this.getNeighbors(index);\n            for (let i = 0; i < neighbors.length; i++) {\n                const neighborIndex = neighbors[i];\n                if (grid[neighborIndex] !== null && grid[neighborIndex]!.state === CellState.BOMB) {\n                    bombProximityCounter++;\n                }\n            }\n            const cell: Cell = {\n                hover: false,\n                visibility: Visibility.INVISIBLE,\n                state: CellState.CLEAN,\n                value: bombProximityCounter as CellValue,\n            };\n            grid[index] = cell;\n        }\n\n        return grid as Cell[];\n    }\n\n    private getNeighbors(index: number): number[] {\n        if (index < 0 || index >= this.games.area) {\n            return [];\n        }\n        const row = Math.floor(index / this.games.width);\n        const col = index % this.games.width;\n        const neighbors = [];\n        for (let j = 0; j < 8; j++) {\n            let tempRow = row;\n            let tempCol = col;\n            switch (j) {\n                case 0:\n                    tempRow -= 1;\n                    tempCol -= 1;\n                    break;\n                case 1: tempRow -= 1; break;\n                case 2:\n                    tempRow -= 1;\n                    tempCol += 1;\n                    break;\n                case 3: tempCol -= 1; break;\n                case 4: tempCol += 1; break;\n                case 5:\n                    tempRow += 1;\n                    tempCol -= 1;\n                    break;\n                case 6: tempRow += 1; break;\n                case 7:\n                    tempRow += 1;\n                    tempCol += 1;\n                    break;\n            }\n            const tempIndex = this.getIndex(tempRow, tempCol);\n            if (tempRow >= 0 && tempRow < this.games.height && // check if the index is in the gird\n                tempCol >= 0 && tempCol < this.games.width) {\n                neighbors.push(tempIndex);\n            }\n        }\n        \n        return neighbors;\n    }\n\n    public draw(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        this.drawBackground(ctx);\n        this.drawBoard(ctx, canvasWindow);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        const gradient1 = ctx.createLinearGradient(this.width / 2,\n            this.height, this.width / 2, 0);\n        gradient1.addColorStop(0.05, '#333');\n        if (this.settings.vibrantColors) {\n            gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 50%, 1)`);\n        } else {\n            gradient1.addColorStop(1, `hsla(${360 - this.backgroundAnimation.getValue()}, 100%, 20%, .8)`);\n        }\n        ctx.fillStyle = gradient1;\n        ctx.fillRect(0, 0, this.width, this.height);\n        ctx.restore();\n    }\n\n    private drawBoard(ctx: CanvasRenderingContext2D, canvasWindow: CanvasWindow) {\n        const totalPieceSize = this.settings.defaultCellSize + this.settings.gridGapSize;\n        const startingColOffset = Math.max(this.width, canvasWindow.width) - canvasWindow.width;\n        const startingRowOffset = Math.max(this.height, canvasWindow.height) - canvasWindow.height;\n\n        const startingRow = Math.floor(canvasWindow.x / (totalPieceSize + startingColOffset + 1));\n        const startingCol = Math.floor(canvasWindow.y / (totalPieceSize + startingRowOffset + 1));\n\n        const endingCol = Math.min(Math.ceil(\n            (canvasWindow.x + canvasWindow.width - this.offsetWidth) / totalPieceSize) + 1,\n            this.games.width);\n        const endingRow = Math.min(Math.ceil(\n            (canvasWindow.y + canvasWindow.height - this.offsetHeight) / totalPieceSize) + 1,\n            this.games.height);\n\n        for (let row = startingRow; row < endingRow; row++) {\n            for (let col = startingCol; col < endingCol; col++) {\n                // position\n                const x = this.offsetWidth + this.calculateBoardSize(col);\n                const y = this.offsetHeight + this.calculateBoardSize(row);\n                const index = this.getIndex(row, col);\n                const cell = this.grid[index];\n                this.pieceRenderer.drawPiece(ctx, cell, x, y);\n            }\n        }\n    }\n\n    private calculateBoardSize(size: number) {\n        return (size * this.settings.defaultCellSize) + ((size + 1) * this.settings.gridGapSize)\n    }\n}\n","import { Point2d } from \"../models/GameTypes\";\n\nexport default function InSquare(square: {\n    top: number,\n    left: number,\n    size: number,\n}, point: Point2d): boolean {\n    return point.y >= square.top && point.y <= square.top + square.size &&\n        point.x >= square.left && point.x <= square.left + square.size\n}","import { SimpleEventState } from \"../models/EventTypes\";\nimport { Point2d } from \"../models/GameTypes\";\n\ninterface Listener {\n    element: HTMLElement;\n    listeningTo: Array<keyof HTMLElementEventMap>;\n}\n\n// why not use\n// https://reactjs.org/docs/events.html#pointer-events\nexport default class InputController {\n\n    private listeners: { [key: number]: Listener } = {};\n    private timer: number = 0;\n    private touchTimer: number = 0;\n    private touchThreshold: number = 300;\n    private touchPoint?: Point2d;\n    private idCounter: number = 0;\n\n    private state?: SimpleEventState;\n    private previousState?: SimpleEventState;\n\n    /**\n     * Place event listeners on a html element\n     * \n     * @param {HTMLElement} element element events to be placed on\n     * @param {String[]} events events to subscribe to\n     * @returns {number} id that tracks your current input session\n     */\n    public start(element: HTMLElement, events: Array<keyof HTMLElementEventMap>): number {\n        // add to listeners\n        const id = this.uniqueId();\n        this.listeners[id] = {\n            element,\n            listeningTo: []\n        };\n\n        events.forEach((event) => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.addEventListener(event, pointer as any);\n            }\n            else {\n                this.listeners[id].element.addEventListener(event, pointer as any, {\n                    passive: event !== \"contextmenu\",\n                });\n            }\n            this.listeners[id].listeningTo.push(event);\n        });\n\n        return id;\n    }\n\n    /**\n     * Get all event that happened\n     * \n     * Remember to call flush() or else you will get old events that persisted\n     * between frames\n     * \n     * @param {number} id - The events binded to the element you want\n     * @returns {Point2d | null} returns mouses new position or null if the \n     *      mouse hasn't moved since last checked\n     */\n    public pollEvents(id: number): SimpleEventState | undefined {\n        if (this.state) {\n            const rect = this.listeners[id].element.getBoundingClientRect();\n            this.state.pos.x -= rect.left;\n            this.state.pos.y -= rect.top;\n        }\n        return this.state;\n    }\n\n    /**\n     * Remove all of the input state from the controller\n     * @returns {void} \n     */\n    public flush() {\n        this.previousState = this.state;\n        this.state = undefined;\n    }\n\n    public stop(id: number): boolean {\n        if (this.listeners[id] === undefined) {\n            return false;\n        }\n\n        this.listeners[id].listeningTo.forEach(event => {\n            const pointer = this.getFunctionPointer(event);\n            if (event === \"keydown\") {\n                window.removeEventListener(event, pointer as any);\n            } else {\n                this.listeners[id].element.removeEventListener(event, pointer as any);\n            }\n        });\n\n        return true;\n    }\n\n    private getFunctionPointer(eventType: keyof HTMLElementEventMap) {\n        switch (eventType) {\n            case \"mousemove\": return this.mouseEvent;\n            case \"mousedown\": return this.mouseEvent;\n            case \"mouseup\": return this.mouseEvent;\n            case \"contextmenu\": return this.stopContextMenu;\n            case \"touchstart\": return this.touchEvent;\n            case \"touchmove\": return this.touchEvent;\n            case \"touchend\": return this.touchEvent;\n            case \"keydown\": return this.keydownEvent;\n            case \"dblclick\": return this.doubleClickEvent;\n        }\n    }\n\n    private mouseEvent = (event: MouseEvent) => {\n        if (this.previousState && this.previousState.events.includes(\"touch\")) {\n            // this means touch is active\n            return;\n        }\n        if (this.state && this.state.events.includes(\"touch\")) {\n            return;\n        }\n\n        // because state already exists, we need to add new data types\n        // this is because if a mousemove happens first then a mousedown event\n        // happens, the left, middle, and right click events won't update\n        if (this.state) {\n            this.state.events.push(event.type as any);\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousemove\") {\n            this.state.pos = {\n                x: event.pageX,\n                y: event.pageY,\n            };\n            return;\n        }\n        // state has been initialized so just update the values inside of it\n        if (this.state && event.type === \"mousedown\") {\n            this.state.leftClick = [1, 3, 5, 7].includes(event.buttons);\n            this.state.middleClick = [4, 5, 6, 7].includes(event.buttons);\n            this.state.rightClick = [2, 3, 6, 7].includes(event.buttons);\n            return;\n        }\n        // state has not been initialized so create it.\n        this.state = {\n            leftClick:   [1, 3, 5, 7].includes(event.buttons),\n            rightClick:  [2, 3, 6, 7].includes(event.buttons),\n            middleClick: [4, 5, 6, 7].includes(event.buttons),\n            pos: {\n                x: event.pageX,\n                y: event.pageY,\n            },\n            keys: [],\n            events: [event.type as any]\n        };\n    }\n\n    private stopContextMenu = (event: any) => {\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n    }\n\n    private touchEvent = (event: TouchEvent) => {\n        if (event.type === \"touchstart\") {\n            if (this.touchTimer === 0) {\n                this.timer = Date.now();\n            }\n            this.touchPoint = {\n                x: event.targetTouches[0].pageX,\n                y: event.targetTouches[0].pageY,\n            };\n            return;\n        }\n\n        if (event.type === \"touchmove\") {\n            this.touchPoint = undefined;\n            return;\n        }\n\n        if (event.type === \"touchend\" && this.touchPoint) {\n            const delta = Date.now() - this.timer;\n            this.timer = Date.now();\n            this.touchTimer += delta;\n            this.state = {\n                leftClick: this.touchTimer < this.touchThreshold,\n                middleClick: false,\n                rightClick: this.touchTimer > this.touchThreshold,\n                pos: this.touchPoint!,\n                keys: (this.state) ? this.state!.keys : [],\n                events: [\"touch\"]\n            }\n            this.touchPoint = undefined;\n            this.touchTimer = 0;\n        }\n    }\n\n    private keydownEvent = (event: KeyboardEvent) => {\n        if(this.state) {\n            this.state.events.push(event.type as any);\n        }\n        if (this.state) {\n            this.state.keys.push(event.key);\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1 },\n                keys: [event.key],\n                events: [event.type as any]\n            };\n        }\n    }\n\n    /**\n     * This only gets triggered when \n     */\n    private doubleClickEvent = (event: MouseEvent) => {\n        if (this.state) {\n            this.state.events.push(event.type as any)\n        } else {\n            this.state = {\n                leftClick: false,\n                middleClick: false,\n                rightClick: false,\n                pos: { x: -1, y: -1},\n                keys: [],\n                events: [event.type as any]\n            }\n        }\n    }\n\n    private uniqueId() {\n        return this.idCounter++;\n    }\n}\n","import React from 'react';\nimport toHHMMSS from '../util/toHHMMSS';\nimport piece from \"../assets/piece.svg\";\nimport hourglass from \"../assets/hourglass.svg\";\nimport \"./Header.css\"\nimport { Link } from 'react-router-dom';\n\ninterface Props {\n    time: number;\n    left: number;\n    pieces: number;\n}\n\nconst GameHeader: React.FC<Props> = (props: Props) => {\n    return <header className=\"header  header--game\">\n        <div className=\"header__detail\" >\n            <img src={piece} alt=\"Home\" />\n            <span>{props.left}/{props.pieces}</span>\n        </div>\n        <h3>\n            <Link to=\"/\">BombFinder</Link>\n        </h3>\n        <div className=\"header__detail\">\n            <span>{toHHMMSS(props.time)}</span>\n            <img src={hourglass} alt=\"Home\" />\n        </div>\n    </header>\n}\n\nexport default GameHeader;","import React from 'react';\nimport \"./Switch.css\";\n\ninterface Props {\n    checked: boolean;\n    onChange: (event: React.FormEvent<HTMLInputElement>) => void;\n}\n\nconst Switch: React.FC<Props> = (props: Props) => {\n    return <label className=\"switch\">\n        <input\n            checked={props.checked}\n            onChange={props.onChange}\n            className=\"switch__input\"\n            type=\"checkbox\" />\n        <span className=\"switch__box\">\n            <span className=\"switch__marker\" />\n        </span>\n    </label>\n}\n\nexport default Switch;","import React from 'react';\nimport info from \"../assets/info.svg\";\nimport settings from \"../assets/cog-f.svg\";\nimport { Link } from 'react-router-dom';\nimport \"./Footer.css\"\nimport Switch from './Switch';\n\ninterface Props {\n    isSwitchChecked?: boolean;\n    flagToggle: (value: boolean) => void;\n}\n\nconst GameFooter: React.FC<Props> = (props: Props) => {\n    const isChecked = (props.isSwitchChecked) ? true : false;\n    return (\n        <footer className=\"footer footer--game\">\n            <Link to=\"/how-to-play\">\n                <img src={info} alt=\"Info\" />\n            </Link>\n            <div className=\"footer__text\">\n                <span>Clear</span>\n                <Switch\n                    checked={isChecked}\n                    onChange={(event: any) => props.flagToggle(event.target.checked) }/>\n                <span>Flag</span>\n            </div>\n            <Link to=\"/settings\">\n                <img src={settings} alt=\"Settings\" />\n            </Link>\n        </footer>\n    );\n}\n\nexport default GameFooter;","import React, { Component } from 'react';\nimport BombFinder from \"../logic/BombFinder\";\nimport InputController from \"../logic/InputController\";\nimport { Redirect } from 'react-router-dom';\nimport { GameProgress } from '../models/GameTypes';\nimport { CanvasWindow } from '../logic/BombFinderPieceRenderer';\nimport Games from '../models/Games';\nimport Loading from './Loading';\nimport Preferences from '../models/Preferences';\nimport Button from './Button';\nimport GameHeader from './Gameheader';\nimport GameFooter from './GameFooter';\nimport './GameBoard.css';\n\ninterface Props {\n    id: string;\n    onGameFinished: (result: GameProgress) => void\n}\n\ninterface State {\n    ready: boolean;\n    gameOver: boolean;\n    canVibrate: boolean;\n    canTryAgain: boolean;\n    toMainMenu: boolean;\n    totalPieces: number;\n    remainingAvailablePiece: number;\n    newGameId?: string;\n    inputId?: number;\n    time: number;\n}\n\nclass GameBoard extends Component<Props, State> {\n\n    private stopUpdates: boolean = false;\n    private rafId?: number;\n\n    private container?: HTMLDivElement;\n    private canvas?: HTMLCanvasElement;\n    // TODO: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#Turn_off_transparency\n    private context2D?: CanvasRenderingContext2D;\n    private gameState?: BombFinder;\n    private input?: InputController;\n\n    state: Readonly<State> = {\n        ready: false,\n        gameOver: false,\n        canVibrate: false,\n        canTryAgain: false,\n        toMainMenu: false,\n        totalPieces: 0,\n        remainingAvailablePiece: 0,\n        time: 0,\n    }\n\n    public componentDidUpdate(prevProps: Props, prevState: State) {\n        if (prevState.newGameId && prevProps.id !== prevState.newGameId) {\n            // new game has started without unmounting the component\n            this.setState({\n                ready: false,\n                gameOver: false,\n                canTryAgain: false,\n                time: 0,\n                newGameId: undefined,\n                inputId: undefined,\n            });\n            this.destroyGame();\n            this.createGame();\n        }\n    }\n\n    public async componentDidMount() {\n        this.createGame();\n    }\n\n    public componentWillUnmount() {\n        this.stopUpdates = true;\n        this.destroyGame();\n    }\n\n    public async createGame() {\n        // TODO: GetById error handling\n        const games = await Games.GetById(this.props.id)!;\n        const preferences = await Preferences.GetPreferences();\n        const page = document.getElementById(\"page\") as HTMLDivElement;\n        if (games.result === \"won\") {\n            this.props.onGameFinished(games.result);\n            return;\n        }\n        // TODO: Remove magic number\n        this.gameState = new BombFinder(games, preferences, page.clientWidth, page.clientHeight - 120);\n        this.input = new InputController();\n        this.setState({\n            ready: true,\n            totalPieces: games.totalPieces,\n            remainingAvailablePiece: this.gameState.getRemainingAvailablePiece\n        });\n        this.canvas = document.getElementById(\"board\") as HTMLCanvasElement;\n        this.container = document.getElementById(\"board-container\") as HTMLDivElement;\n        this.context2D = this.canvas.getContext(\"2d\")!;\n\n        const inputId = this.input.start(this.canvas!, [\"mousemove\", \"mousedown\",\n            \"contextmenu\", \"touchstart\", \"touchmove\", \"touchend\", \"keydown\" /*, \"dblclick\" */]); \n        // TODO: Add error handling\n        this.canvas!.width = this.gameState!.gameBoardWidth;\n        this.canvas!.height = this.gameState!.gameBoardHeight;\n        this.container.scrollLeft = (this.gameState!.gameBoardWidth - window.innerWidth) / 2;\n        this.container.scrollTop = (this.gameState!.gameBoardHeight - window.innerHeight) / 2;\n        this.setState({ ready: true, inputId: inputId, canVibrate: preferences.vibration });\n        requestAnimationFrame(this.draw);\n    }\n\n    public destroyGame() {\n        if (this.state.ready && this.state.inputId) {\n            this.input!.stop(this.state.inputId!);\n        }\n        if (this.rafId) {\n            cancelAnimationFrame(this.rafId!);\n        }\n    }\n\n    public changeInputMode = (markFlag: boolean) => {\n        this.gameState!.setMarkInput(markFlag);\n        this.forceUpdate();\n    }\n\n    public tryAgain = async () => {\n        if (this.state.ready && !this.state.newGameId && this.state.canTryAgain) {\n            try {\n                const newGameId = await this.gameState!.reset();\n                this.setState({ ready: false, newGameId });\n            } catch (e) {\n                console.warn(\"error \" + e);\n                // TODO: implement Error handling\n            }\n        }\n    }\n\n    public goToMainMenu = async () => {\n        if (this.state.ready) {\n            const logged = await this.gameState!.logAndDestroy();\n            if (logged) {\n                this.setState({toMainMenu: true});\n            }\n        }\n    }\n\n    public render() {\n        if (this.state.toMainMenu) {\n            return <Redirect to=\"/\" />;\n        }\n        if (this.state.newGameId) {\n            const route = `/game/${this.state.newGameId}`;\n            return <Redirect to={route} />;\n        }\n        if (!this.state.ready) {\n            return <Loading />\n        }\n        const dimensions = {\n            height: this.gameState!.gameBoardHeight,\n            width: this.gameState!.gameBoardWidth,\n        };\n        let canvasBoardClass = \"board__canvas \" + this.gameState!.gameBoardOverflowClasses;\n        return (\n            <div className=\"board\">\n                <GameHeader time={this.gameState!.getTime}\n                    left={this.state.remainingAvailablePiece}\n                    pieces={this.state.totalPieces}/>\n                <div className={canvasBoardClass} id=\"board-container\">\n                    <canvas id=\"board\"\n                        className={this.gameState!.gameState}\n                        width={dimensions.width}\n                        height={dimensions.height} />\n                    {(this.state.gameOver)\n                        ? <div className=\"board__popup\">\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Try Again\"\n                                onClick={this.tryAgain} />\n                            <Button className=\"board__popup__item\"\n                                type=\"button\"\n                                text=\"Main Menu\"\n                                onClick={this.goToMainMenu} />\n                        </div>\n                        : null\n                    }\n                </div>\n                <GameFooter\n                    isSwitchChecked={!this.gameState!.isInputModeToggle}\n                    flagToggle={this.changeInputMode} />\n            </div>\n        );\n    }\n\n    private draw = () => {\n        if (!this.state.ready) {\n            // TODO: do we need this ready check for the game?????\n            return;\n        }\n        const elapsedTime = 0.0167;\n        const events = this.input!.pollEvents(this.state.inputId!);\n        \n        if (events) {\n            this.gameState!.handleEvents(events);\n            if (events.keys.length > 0) {\n                this.forceUpdate();\n            }\n        }\n        this.gameState!.update(elapsedTime);\n        // TODO: calculate playing area and send it to draw\n        const viewport: CanvasWindow = {\n            x: this.container!.scrollLeft, y: this.container!.scrollTop,\n            width: this.container!.clientWidth, height: this.container!.clientHeight\n        };\n        this.gameState!.draw(this.context2D!, viewport);\n        \n        // Initial draw call before any events\n        if (this.rafId === undefined || this.gameState!.isGameOver) {\n            this.gameState!.draw(this.context2D!, viewport);\n        }\n        \n        this.input!.flush();\n        \n        \n        if (this.gameState!.isGameOver) {\n            if (this.gameState!.isGameWon) {\n                this.props.onGameFinished(\"won\");\n            } else {\n                if (this.state.canVibrate && navigator.vibrate) {\n                    navigator.vibrate(200);\n                }\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    gameOver: true,\n                    canVibrate: false,\n                    canTryAgain: true,\n                });\n            }\n        }\n\n        if (!this.stopUpdates) {\n            this.rafId = requestAnimationFrame(this.draw);\n            if (this.state.time !== this.gameState!.getTime) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece,\n                    time: this.gameState!.getTime\n                });\n            } else if (this.state.remainingAvailablePiece !== this.gameState!.getRemainingAvailablePiece) {\n                this.setState({\n                    remainingAvailablePiece: this.gameState!.getRemainingAvailablePiece\n                });\n            }\n        }\n    }\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport { GameProgress } from '../models/GameTypes';\nimport GameBoard from '../components/GameBoard';\nimport { RouteComponentProps, Redirect } from 'react-router';\nimport Games from '../models/Games';\nimport PageNotFound from './page-not-found';\n\ninterface ParamProps {\n    id: string;\n}\n\ntype Props = RouteComponentProps<ParamProps>;\n\ninterface State {\n    // for when the game is done\n    to404Page: boolean;\n    toWonPage: boolean;\n    redirecting: boolean;\n    ready: boolean;\n}\n\nexport default class Game extends Component<Props, State> {\n\n    state: Readonly<State> = {\n        to404Page: false,\n        toWonPage: false,\n        redirecting: false,\n        ready: false,\n    }\n\n    async componentDidMount() {\n        const exists = await Games.DoesGameExists(this.props.match.params.id);\n        if (exists) {\n            this.setState({ to404Page: false, ready: true });\n        }\n        else {\n            this.setState({ to404Page: true, ready: true });\n        }\n    }\n\n    gameFinished = (result: GameProgress) => {\n        this.setState({ toWonPage: result === \"won\" });\n    }\n\n    public render() {\n        if (this.state.toWonPage) {\n            return <Redirect to={`/game/${this.props.match.params.id}/game-won`} />\n        }\n        else if (this.state.to404Page) {\n            return <PageNotFound />;\n        }\n        else if (this.state.ready) {\n            return <GameBoard\n                id={this.props.match.params.id}\n                onGameFinished={this.gameFinished} />\n        } else {\n            return null;\n        }\n    }\n}\n","import React from 'react';\nimport \"./Button.css\"\n\ninterface Props {\n    type: \"button\" | \"submit\";\n    className?: string;\n    disabled?: boolean;\n    text: string;\n    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void\n}\n\n/**\n * Taken from:\n * https://codepen.io/finnhvman/pen/zpygBB\n */\nconst Button: React.FC<Props> = ({ type, disabled, className, text, onClick }) => {\n    const disabledClass = (disabled) ? \"button disabled\" : \"button\";\n    const classes = (className) ? `${className} ${disabledClass}` : disabledClass;\n    if (onClick) {\n        return <button className={classes}\n            disabled={disabled}\n            type={type}\n            onClick={onClick}>\n            {text}\n        </button>\n    }\n    return <button className={classes} disabled={disabled} type={type}>{text}</button>\n}\n\nexport default Button;","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export enum Visibility {\n    INVISIBLE, // show default animation\n    VISIBLE,   // show the cell value\n    VISIBLY_SATISFIED, // show the cell's value in diffrent color\n    MARKED,    // show marked cell\n}\n\nexport const isVisible = (v: Visibility) => \n    v === Visibility.VISIBLE || v === Visibility.VISIBLY_SATISFIED;\n\nexport const isMarkable = (v: Visibility) =>\n    v === Visibility.MARKED || v === Visibility.INVISIBLE;\n\nexport const isMarked = (cell: Cell) => \n    cell.visibility === Visibility.MARKED;\n\nexport enum CellState {\n    BOMB,  // cell is a bomb\n    CLEAN, // cell is clean\n}\n\nexport type CellValue = null | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\nexport const incrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 0: return 1;\n        case 1: return 2;\n        case 2: return 3;\n        case 3: return 4;\n        case 4: return 5;\n        case 5: return 6;\n        case 6: return 7;\n        case 7: return 8;\n        // these last 2 cases should rarely be called\n        case 8: return 8;\n        default: return null\n    }\n}\n\nexport const decrementCellValue = (value?: CellValue): CellValue => {\n    switch (value) {\n        case 1: return 0;\n        case 2: return 1;\n        case 3: return 2;\n        case 4: return 3;\n        case 5: return 4;\n        case 6: return 5;\n        case 7: return 6;\n        case 8: return 7;\n        // these last 2 cases should rarely be called\n        case 0: return 0;\n        default: return null\n    }\n}\n\nexport const isBomb = (cv?: CellValue) => cv === null || cv === undefined;\n\nexport interface Cell {\n    hover: boolean;\n    visibility: Visibility;\n    readonly state: CellState;\n    readonly value?: CellValue;\n}\n","\n\nexport default function RandInRange(min: number, max: number) {\n    return Math.floor(Math.random() * max) + min;\n}","import { Cell, Visibility, isBomb, CellValue } from \"../models/GameBoardTypes\";\nimport RandInRange from \"../util/Random\";\nimport { IPreferences } from \"../models/Preferences\";\n\nexport interface CanvasWindow {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\n/**\n * All the renderer cares about is rendering\n * a piece of the board.\n * \n * When drawing, you will pass in all the cell\n * details and it will be drawn\n */\nexport default class BombFinderPieceRenderer {\n    /**\n     * Constants\n     */\n    private readonly RECTANGLE_REDIS_DEGREE = 6;\n    private readonly LINE_WIDTH_DEGREE = 20;\n    private readonly ROTATING_LINE_WIDTH_DEGREE = 60;\n    private readonly PIECE_MARKED_COLOR = \"#3396ff\";\n\n    /**\n     * Invisible\n     * Invisible Marked\n     * 0 cell\n     * bomb cell\n     * 1-8 cells\n     * 1-8 cells satisfied\n     */\n    // the offsreen canvas can be this.pieceLength * 20 by this.pieceLength\n    // then when we are drawing we just grab the offset\n    // why not 3 diffrent canvases, animated get there own\n\n    // TODO: Add more off screen canvas updating\n    private invisiblePieceCanvas: HTMLCanvasElement;\n    private invisibleMarkedPieceCanvas: HTMLCanvasElement;\n    private staticPieceCanvas: HTMLCanvasElement[] = [];\n    // private pieceAnimations: AnimationTimer[] = [];\n    private pieceAnimations: number[] = [];\n\n    private lineWidth: number;\n    private pieceLength: number;\n    private gapSize: number;\n    private simpleRender: boolean;\n    private exampleCellValue = RandInRange(0, 8);\n\n    constructor(settings: IPreferences) {\n        this.lineWidth = settings.defaultCellSize / this.LINE_WIDTH_DEGREE;\n        this.pieceLength = settings.defaultCellSize - this.lineWidth * 2;\n        this.gapSize = settings.gridGapSize;\n        this.simpleRender = settings.simpleRender;\n        this.setSpinningCubes(settings.spinningCubes);\n        // set up canvas\n        this.invisiblePieceCanvas = document.createElement(\"canvas\");\n        this.invisiblePieceCanvas.height = settings.defaultCellSize;\n        this.invisiblePieceCanvas.width =  settings.defaultCellSize;\n        this.drawInvisiblePiece(this.invisiblePieceCanvas.getContext('2d')!, this.lineWidth, this.lineWidth);\n\n        this.invisibleMarkedPieceCanvas = document.createElement(\"canvas\");\n        this.invisibleMarkedPieceCanvas.height = settings.defaultCellSize;\n        this.invisibleMarkedPieceCanvas.width = settings.defaultCellSize;\n        this.drawInvisiblePiece(this.invisibleMarkedPieceCanvas.getContext('2d')!, this.lineWidth, this.lineWidth, this.PIECE_MARKED_COLOR);\n\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i] = document.createElement(\"canvas\");\n            this.staticPieceCanvas[i].width = settings.defaultCellSize;\n            this.staticPieceCanvas[i].height = settings.defaultCellSize;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, num, this.PIECE_MARKED_COLOR);\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, 0);\n            } else {\n                this.drawVisibleCell(ctx, this.lineWidth, this.lineWidth, undefined);\n            }\n        }\n    }\n\n    /**\n     * Update the size of a cells width and height\n     * @param value height and width to set the piece\n     */\n    setCellSize(value: number) {\n        this.lineWidth = value / this.LINE_WIDTH_DEGREE;\n        this.pieceLength = value - this.lineWidth * 2;\n        // hard code invis\n        this.invisiblePieceCanvas.height = value;\n        this.invisiblePieceCanvas.width = value;\n        // marked invis\n        this.invisibleMarkedPieceCanvas.height = value;\n        this.invisibleMarkedPieceCanvas.width = value;\n        // everything else\n        for (let i = 0; i < 18; i++) {\n            this.staticPieceCanvas[i].width = value;\n            this.staticPieceCanvas[i].height = value;\n            const ctx = this.staticPieceCanvas[i].getContext('2d')!;\n            if (i < 8) {\n                this.drawVisibleCell(ctx, 0, 0, (i + 1 as CellValue));\n            } else if (i < 16) {\n                const num: CellValue = (i % 8) + 1 as CellValue;\n                this.drawVisibleCell(ctx, 0, 0, num, this.PIECE_MARKED_COLOR);\n            } else if (i < 17) {\n                this.drawVisibleCell(ctx, 0, 0, 0);\n            } else {\n                this.drawVisibleCell(ctx, 0, 0, undefined);\n            }\n        }\n    }\n\n    /**\n     * Set the gab size found between pieces\n     * @param value size of gap in pixels\n     */\n    setGapSize(value: number) {\n        this.gapSize = value;\n    }\n\n    /**\n     * Set the number of cubes that spin inside of invisible pieces\n     * @param value number of spinning cubes found on invisible pieces\n     */\n    setSpinningCubes(value: number) {\n        this.pieceAnimations = [];\n        for (let i = value + 1; i >= 1; i--) {\n            this.pieceAnimations.push(0);\n                // new AnimationTimer(90 * i, Math.pow(i + 1, i * .035) - 1, LoopOptions.ALTERNATE));\n        }\n    }\n\n    /**\n     * Toggle simple render option\n     * @param value property to toggle simple render to\n     */\n    setSimpleRender(value: boolean) {\n        this.simpleRender = value;\n    }\n\n    private reverseTiming: boolean = false;\n    /**\n     * Update dynamic pieces (spinning cubes)\n     * return early if simple render is on\n     * @param delta elapsed seconds\n     */\n    update(delta: number) {\n        if (this.simpleRender || this.pieceAnimations.length === 0) {\n            return;\n        }\n        let reverse: boolean[] = [];\n        for (let i = 0; i < this.pieceAnimations.length; i++) {\n            let index = i;\n            if (this.reverseTiming) {\n                index = this.pieceAnimations.length - i;\n            }\n            const oldTime = this.pieceAnimations[index]\n            const newTime = this.pieceAnimations[index] + (delta * (index) * 1);\n            if (this.reverseTiming) {\n                if (Math.sin(newTime) < Math.sin(oldTime)) {\n                    this.pieceAnimations[index] = newTime;\n                    reverse.push(false);\n                } else {\n                    reverse.push(true);\n                }\n            } else {\n                if (Math.sin(newTime) > Math.sin(oldTime)) {\n                    this.pieceAnimations[index] = newTime;\n                    reverse.push(true);\n                } else {\n                    reverse.push(false);\n                }\n            }\n        }\n        const allSame = reverse.every(b => b === reverse[0]);\n        if (allSame) {\n            this.reverseTiming = !this.reverseTiming;\n        }\n\n        // get context\n        const ipcContext = this.invisiblePieceCanvas.getContext('2d')!;\n        const impcContext = this.invisibleMarkedPieceCanvas.getContext('2d')!;\n        // clear canvas\n        const length = this.pieceLength + (this.lineWidth * 2)\n        ipcContext.clearRect(0, 0, length, length);\n        impcContext.clearRect(0, 0, length, length);\n        // draw canvas\n        this.drawInvisiblePiece(ipcContext, this.lineWidth, this.lineWidth);\n        this.drawInvisiblePiece(impcContext, this.lineWidth, this.lineWidth, this.PIECE_MARKED_COLOR);\n    }\n\n    /**\n     * Create graphical gird cell without actually providing one\n     * @param ctx canvas context\n     * @param x x position\n     * @param y y position\n     * @param visibility Cell visibility\n     */\n    drawPlaceHolder(ctx: CanvasRenderingContext2D, x: number, y: number, visibility: Visibility = Visibility.INVISIBLE) {\n        ctx.save();\n        switch (visibility) {\n            case Visibility.INVISIBLE: this.drawInvisiblePiece(ctx, x, y); break;\n            case Visibility.MARKED: this.drawInvisiblePiece(ctx, x, y, this.PIECE_MARKED_COLOR); break;\n            case Visibility.VISIBLE: this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue); break;\n            case Visibility.VISIBLY_SATISFIED:\n                this.drawVisibleCell(ctx, x, y, this.exampleCellValue as CellValue, this.PIECE_MARKED_COLOR); break;\n        }\n        ctx.restore();\n    }\n\n    /**\n     * Create graphical grid cell\n     * @param ctx canvas\n     * @param cell grid cell\n     * @param x x position\n     * @param y y position\n     */\n    drawPiece(ctx: CanvasRenderingContext2D, cell: Cell, x: number, y: number) {\n        if (cell.visibility === Visibility.INVISIBLE) {\n            ctx.drawImage(this.invisiblePieceCanvas, x, y);\n            if (cell.hover) {\n                const offset = this.lineWidth / 2;\n                this.drawHover(ctx, x + offset, y + offset);\n                // add this as a debug feature cause its actually cool\n                // const index = this.getIndexByCell(cell);\n                // ctx.drawImage(this.staticPieceCanvas[index], x, y);\n            }\n        } else if (cell.visibility === Visibility.MARKED) {\n            ctx.drawImage(this.invisibleMarkedPieceCanvas, x, y);\n        } else {\n            const index = this.getIndexByCell(cell);\n            ctx.drawImage(this.staticPieceCanvas[index], x, y);\n        }\n    }\n\n    /**\n     * get the index of the cached canvas that matches the cell's state\n     * @param cell Cell\n     */\n    private getIndexByCell(cell: Cell) {\n        if (isBomb(cell.value)) {\n            return 17;\n        } else if (cell.value === 0) {\n            return 16;\n        } else {\n            if (cell.visibility === Visibility.VISIBLY_SATISFIED) {\n                return cell.value! - 1 + 8;\n            }\n            return cell.value! - 1;\n        }\n    }\n\n    /**\n     * Draw an invisible piece\n     * @param ctx canvas\n     * @param x x position\n     * @param y y pixel position\n     * @param overrideColor color to use instead of default color (#FFF)\n     */\n    private drawInvisiblePiece(ctx: CanvasRenderingContext2D, x: number, y: number, overrideColor?: string) {\n        if (!this.simpleRender) {\n            ctx.save();\n            let s = this.pieceLength * 0.9;\n            let offset = this.pieceLength * 0.05;\n            for (let i = 1; i < this.pieceAnimations.length + 1; i++) {\n                const rotation =Math.sin(this.pieceAnimations[i]);\n                let index = this.pieceAnimations.length - 1;\n                s += rotation * Math.pow(index, 0.25);\n                offset += (rotation * -Math.pow(index, 0.25)) / 2;\n                this.drawRotatingSquare(ctx, offset + x, y + offset, s, i, rotation, overrideColor);\n                offset += (s / 4) / 2;\n                s = (s / 4) * 3;\n            } \n            ctx.restore();\n        }\n        \n\n        ctx.save();\n        ctx.beginPath();\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"#FFF\";\n        }\n        this.drawSquare(ctx, x, y, this.pieceLength / this.RECTANGLE_REDIS_DEGREE, this.pieceLength);\n\n        ctx.lineWidth = this.lineWidth;\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n    }\n\n    /**\n     * Draw one rotating cube\n     * @param ctx canvas\n     * @param worldX x pixel position\n     * @param worldY y pixel position\n     * @param cellLength spinning cube width\n     * @param i index\n     * @param rotationDirection direction to rotate\n     * @param overrideColor color to use instead of default color (#FFF)\n     */\n    private drawRotatingSquare(ctx: CanvasRenderingContext2D, worldX: number, worldY: number, cellLength: number,\n        i: number, rotation: number, overrideColor?: string) {\n        const radius = cellLength / this.RECTANGLE_REDIS_DEGREE;\n        let totalLength = cellLength / 2 + (radius * 2);\n        let x = worldX + cellLength / 4 - radius;\n        let y = worldY + cellLength / 4 - radius;\n\n        ctx.save();\n        ctx.beginPath();\n        // Draw the rotating bits inside of the circle\n        ctx.translate(x + + (totalLength / 2), y + totalLength / 2);\n        ctx.rotate(rotation);\n        ctx.translate((x + totalLength / 2) * -1, (y + totalLength / 2) * -1);\n        this.drawSquare(ctx, x, y, radius, totalLength);\n        let lineWidth = this.pieceLength / this.ROTATING_LINE_WIDTH_DEGREE;\n        if (lineWidth < 1) {\n            lineWidth = 1;\n        }\n        ctx.lineWidth = lineWidth;\n        if (overrideColor) {\n            ctx.strokeStyle = overrideColor;\n        } else {\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.4)\";\n        }\n\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    /**\n     * Draw a square on the canvas\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     * @param radius border radius\n     * @param length width and height of rectangle\n     */\n    private drawSquare(ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, length: number) {\n        // start\n        ctx.moveTo(x + radius, y);\n        // top\n        ctx.lineTo(x + length - radius, y);\n        ctx.quadraticCurveTo(x + length, y, x + length, y + radius);\n        // right\n        ctx.lineTo(x + length, y + length - radius);\n        ctx.quadraticCurveTo(x + length, y + length, x + length - radius, y + length);\n        // bottom\n        ctx.lineTo(x + radius, y + length);\n        ctx.quadraticCurveTo(x, y + length, x, y + length - radius);\n        // left\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n    }\n    \n    /**\n     * Draw multiple squares at different alpha values to give the appearance of \n     * a gradient\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     */\n    private drawHover(ctx: CanvasRenderingContext2D, x: number, y: number) {\n        ctx.save()\n        const gapSize = (this.gapSize / 2)\n        let alpha = 1.0;\n        let step = 1 / gapSize;\n        x += (1 + this.lineWidth) / 2;\n        y += (1 + this.lineWidth) / 2;\n        for (let i = 1; i <= gapSize; i++) {\n            ctx.beginPath();\n            ctx.strokeStyle = `rgba(255,255,255, ${alpha})`;\n            this.drawSquare(ctx, x - i, y - i, (this.pieceLength) / this.RECTANGLE_REDIS_DEGREE,\n                this.pieceLength + (i * 2));\n            if ((i + 1) >= (this.gapSize / 2)) {\n                ctx.lineWidth = 1;\n            } else {\n                ctx.lineWidth = 2;\n            }\n            alpha -= step;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n\n    /**\n     * Draw a visible cell that matches the cell value\n     * @param ctx canvas\n     * @param x x pixel position\n     * @param y y pixel position\n     * @param cellValue bomb state value\n     * @param overrideColor color to use instead of default color\n     */\n    private drawVisibleCell(ctx: CanvasRenderingContext2D, x: number, y: number, cellValue?: CellValue, overrideColor?: string) {\n        ctx.save();\n        ctx.beginPath();\n        let length = this.pieceLength;\n        if (isBomb(cellValue)) {\n            // let radius = 3;\n            // draw the outline of the shape\n            ctx.save();\n            ctx.beginPath();\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#690721\";\n            ctx.lineWidth = 4;\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n            // draw inner circle\n            ctx.save();\n            ctx.beginPath();\n            length -= 6;\n            ctx.arc(x + 3 + length / 2, y + 3 + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.strokeStyle = \"#f00f4b\";\n            ctx.lineWidth = 3;\n            // gradient \n\n            const innerX = x + (length / 2);\n            const innerY = y + (length / 2);\n            var gradient = ctx.createRadialGradient(\n                innerX, innerY, this.pieceLength / 6,\n                innerX, innerY, this.pieceLength / 2);\n\n            // Add three color stops\n            gradient.addColorStop(0, '#333');\n            gradient.addColorStop(1, '#690721');\n\n            // fill shap\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.stroke();\n            ctx.closePath();\n            ctx.restore();\n\n        } else if (cellValue === 0) {\n            this.drawSquare(ctx, x, y, this.pieceLength / this.RECTANGLE_REDIS_DEGREE, this.pieceLength);\n            ctx.lineWidth = this.lineWidth;\n            ctx.strokeStyle = \"gray\";\n        } else {\n            if (overrideColor) {\n                ctx.fillStyle = overrideColor;\n                ctx.strokeStyle = overrideColor;\n            } else {\n                ctx.fillStyle = \"#FFFFFF\";\n                ctx.strokeStyle = \"#FFFFFF\"\n            }\n            // http://www.ckollars.org/canvas-text-centering.html\n            ctx.font = `normal ${this.pieceLength}px sans-serif`;\n            // const measurements = ctx.measureText(String(cell.value));\n            const offset = (this.pieceLength / 2) + (this.lineWidth * 1.5);\n            const ypos = y + (this.pieceLength / 2) + offset;// + this.pieceLength;\n            const xpos = x + (this.pieceLength / 2);\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"bottom\";\n            ctx.arc(x + length / 2, y + length / 2, length / 2, 0, 2 * Math.PI);\n            ctx.lineWidth = this.lineWidth;\n            ctx.fillText(String(cellValue), xpos, ypos);\n        }\n        ctx.closePath();\n        ctx.stroke();\n        ctx.restore();\n    }\n}","export default function toHHMMSS(time: number) {\n    time = Math.floor(time);\n    const hours = Math.floor(time / 3600);\n    const minutes = Math.floor((time - (hours * 3600)) / 60);\n    const seconds = time - (hours * 3600) - (minutes * 60);\n    let timeString = \"\";\n\n    if (hours > 0) {\n        timeString += (hours < 10) ? `0${hours}:` : `${hours}:`;\n    }\n    timeString += (minutes < 10) ? `0${minutes}:` : `${minutes}:`;\n    timeString += (seconds < 10) ? `0${seconds}` : `${seconds}`;\n\n    return timeString;\n}","import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import { Table, Field, Query, IDBTable } from \"../logic/MetaDataStorage\";\n\nexport interface IPreferences {\n    // soundVolume: number;\n    // musicVolume: number;\n    defaultCellSize: number; // slider\n    gridGapSize: number;     // slider\n    spinningCubes: number;   // slider\n    simpleRender: boolean;   // checkbox\n    // fullScreen: boolean; // checkbox, don't save\n    vibrantColors: boolean;\n    firstMoveHandicap: boolean;\n    vibration: boolean;\n    timestamp: Date;\n}\n\n@Table(\"settings\")\nexport default class Preferences implements IPreferences, IDBTable {\n    \n    public tableName = \"settings\";\n\n    @Field(\"settings\", true)\n    public readonly id: string = \"preferences\";\n\n    @Field(\"settings\")\n    public defaultCellSize: number = 35;\n\n    @Field(\"settings\")\n    public gridGapSize: number = 8.5;\n\n    @Field(\"settings\")\n    public spinningCubes: number = 7;\n\n    @Field(\"settings\")\n    public simpleRender: boolean = false;\n\n    @Field(\"settings\")\n    public firstMoveHandicap: boolean = true;\n\n    @Field(\"settings\")\n    public vibrantColors: boolean = false;\n\n    @Field(\"settings\")\n    public vibration: boolean = false;\n    \n    @Field(\"settings\")\n    public timestamp: Date = new Date();\n\n    static async GetPreferences(): Promise<IPreferences> {\n        const preferences = new Preferences();\n        const cachedSettings = await Query.getById(preferences, preferences.id);\n        // not defined\n        if (cachedSettings === undefined) {\n            return preferences;\n        } else {\n            return cachedSettings;\n        }\n    }\n\n    static async Save(preferences: IPreferences) {\n        preferences.timestamp = new Date();\n        const settings = Object.assign(new Preferences(), preferences);\n        return await Query.save(settings);\n    }\n\n}","module.exports = __webpack_public_path__ + \"static/media/hourglass.63a5448b.svg\";","import React from 'react';\nimport \"../components/Button.css\"\nimport \"./page-not-found.css\"\nimport { Link } from 'react-router-dom';\n\nconst PageNotFound: React.FC = () => {\n    return <div className=\"page-not-found\">\n        <h1>404</h1>\n        <div className=\"page-not-found__message\">\n            Looks like you've lost your way\n        </div>\n        <Link to=\"/\" className=\"link-button page-not-found__btn\">\n            Go Home\n        </Link>\n    </div>\n}\n\nexport default PageNotFound;","module.exports = __webpack_public_path__ + \"static/media/piece.e03fada0.svg\";"],"sourceRoot":""}